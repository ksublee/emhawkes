[{"path":[]},{"path":"https://ksublee.github.io/emhawkes/articles/example.html","id":"univariate-hawkes-process","dir":"Articles","previous_headings":"Basic Hawkes model","what":"Univariate Hawkes process","title":"Example : emhawkes package","text":"subsection outlines steps constructing, running simulations, estimating univariate Hawkes model. begin, create hspec object, defines Hawkes model. S4 class hspec contains slots model parameters: mu, alpha, beta, dimens, rmark, impact. univariate model, basic parameters model—mu, alpha, beta—can given numeric values. numeric values provided, converted matrices. example univariate Hawkes model without mark. function hsim implements simulation input arguments hspec, size, initial values intensity component process, lambda_component0, initial values Hawkes processes, N0. precisely, intensity process basic univariate Hawkes model represented λ(t)=μ+∫−∞tαe−β(t−s)dN(s)=μ+λc(0)e−βt+∫0tαe−β(t−s)dN(s) \\lambda(t) = \\mu + \\int_{-\\infty}^t \\alpha e^{-\\beta (t-s)} d N(s) = \\mu + \\lambda_c(0) e^{-\\beta t} + \\int_0^t \\alpha e^{-\\beta (t-s)} d N(s) lambda_component0 denotes λc(0)=∫−∞0αeβsdN(s). \\lambda_c(0) = \\int_{-\\infty}^0 \\alpha e^{\\beta s} d N(s). lambda_component0 provided, internally determined initial values intensity process used. size sufficiently large, exact value lambda_component0 may important. default initial value counting process, N0, zero. results hsim S3 class hreal, consists hspec, inter_arrival, arrival, type, mark, N, Nc, lambda, lambda_component, rambda, rambda_component. hspec model specification. inter_arrival inter-arrival time every event. arrival cumulative sum inter_arrival. type type events, .e., ii NiN_i, used multivariate model. mark numeric vector represents additional information event. lambda represents λ\\lambda, left continuous right limit version. right continuous version intensity rambda. lambda_component represents λij\\lambda_{ij}, rambda_component right continuous version. inter_arrival, type, mark, N, Nc start zero. Using summary() function, one can print first 20 elements arrival, N, lambda. print() function can also used. definition, lambda == mu + lambda_component. rows except first, rambda equals lambda + alpha model. Additionally, verify exponential decay accurately represented model. log-likelihood function calculated using logLik method. context, inter-arrival times hspec provided inputs function. likelihood estimation performed using hfit function. specification initial parameter values, hspec0, required. Note inter_arrival needed univariate model. accurate simulation, recommended specify lambda0, initial value lambda component. lambda0 provided, function uses internally determined initial values. default, BFGS method employed numerical optimization.","code":"library(emhawkes) mu1 <- 0.3; alpha1 <- 1.2; beta1 <- 1.5 hspec1 <- new(\"hspec\", mu = mu1, alpha = alpha1, beta = beta1) show(hspec1) #> An object of class \"hspec\" of 1-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,]  0.3 #>  #> Slot alpha:  #>      [,1] #> [1,]  1.2 #>  #> Slot beta:  #>      [,1] #> [1,]  1.5 set.seed(1107) res1 <- hsim(hspec1, size = 1000) summary(res1) #> ------------------------------------------------------- #> Simulation result of exponential (marked) Hawkes model. #> Realized path : #>        arrival N1 mark lambda1 #>  [1,]  0.00000  0    0 0.90000 #>  [2,]  0.97794  1    1 0.43838 #>  [3,]  1.09001  2    1 1.43128 #>  [4,]  1.28999  3    1 2.02711 #>  [5,]  1.53225  4    1 2.33527 #>  [6,]  1.65001  5    1 3.01139 #>  [7,]  2.51807  6    1 1.36377 #>  [8,]  2.81710  7    1 1.74553 #>  [9,]  2.87547  8    1 2.72378 #> [10,]  3.16415  9    1 2.65016 #> [11,]  3.51378 10    1 2.40131 #> [12,]  4.22355 11    1 1.43843 #> [13,] 16.96752 12    1 0.30000 #> [14,] 17.71654 13    1 0.69015 #> [15,] 19.10293 14    1 0.49874 #> [16,] 24.06354 15    1 0.30082 #> [17,] 24.09256 16    1 1.44967 #> [18,] 28.40173 17    1 0.30366 #> [19,] 28.53743 18    1 1.28198 #> [20,] 28.56702 19    1 2.38725 #> ... with 980 more rows  #> ------------------------------------------------------- # first and third columns are the same cbind(res1$lambda[1:5], res1$lambda_component[1:5], mu1 + res1$lambda_component[1:5]) #>          [,1]     [,2]     [,3] #> [1,] 0.900000 0.600000 0.900000 #> [2,] 0.438383 0.138383 0.438383 #> [3,] 1.431282 1.131282 1.431282 #> [4,] 2.027111 1.727111 2.027111 #> [5,] 2.335269 2.035269 2.335269 # second and third columns are the same cbind(res1$lambda[1:5], res1$rambda[1:5], res1$lambda[1:5] + alpha1) #>          [,1]     [,2]     [,3] #> [1,] 0.900000 0.900000 2.100000 #> [2,] 0.438383 1.638383 1.638383 #> [3,] 1.431282 2.631282 2.631282 #> [4,] 2.027111 3.227111 3.227111 #> [5,] 2.335269 3.535269 3.535269 # By definition, the following two are equal: res1$lambda[2:6] #> [1] 0.438383 1.431282 2.027111 2.335269 3.011391 mu1 + (res1$rambda[1:5] - mu1) * exp(-beta1 * res1$inter_arrival[2:6]) #> [1] 0.438383 1.431282 2.027111 2.335269 3.011391 logLik(hspec1, inter_arrival = res1$inter_arrival) #> The initial values for intensity processes are not provided. Internally determined initial values are used. #> loglikelihood  #>     -214.2385 # initial value for numerical optimization mu0 <- 0.5; alpha0 <- 1.0; beta0 <- 1.8 hspec0 <- new(\"hspec\", mu = mu0, alpha = alpha0, beta = beta0) # the intial values are provided through hspec mle <- hfit(hspec0, inter_arrival = res1$inter_arrival) summary(mle) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 24 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -213.4658  #> 3  free parameters #> Estimates: #>        Estimate Std. error t value Pr(> t)     #> mu1     0.33641    0.03475   9.682  <2e-16 *** #> alpha1  1.16654    0.09608  12.141  <2e-16 *** #> beta1   1.52270    0.12468  12.213  <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> --------------------------------------------"},{"path":"https://ksublee.github.io/emhawkes/articles/example.html","id":"bivariate-hawkes-model","dir":"Articles","previous_headings":"Basic Hawkes model","what":"Bivariate Hawkes model","title":"Example : emhawkes package","text":"intensity process basic bivariate Hawkes model defined λ1(t)=μ1+∫−∞tα11e−β11(t−s)dN1(s)+∫−∞tα12e−β12(t−s)dN2(s),  \\lambda_1(t) = \\mu_1 + \\int_{-\\infty}^t \\alpha_{11} e^{-\\beta_{11}(t-s)} d N_1(s) + \\int_{-\\infty}^t \\alpha_{12} e^{-\\beta_{12}(t-s)} d N_2(s), λ2(t)=μ2+∫−∞tα21e−β21(t−s)dN1(s)+∫−∞tα22e−β22(t−s)dN2(s).  \\lambda_2(t) = \\mu_2 + \\int_{-\\infty}^t \\alpha_{21} e^{-\\beta_{21}(t-s)} d N_1(s) + \\int_{-\\infty}^t \\alpha_{22} e^{-\\beta_{22}(t-s)} d N_2(s). bivariate model, parameters within slots hspec matrices. Specifically, mu 2--1 matrix, alpha beta 2--2 matrices. μ=[μ1μ2],α=[α11α12α21α22],β=[β11β12β21β22] \\mu = \\begin{bmatrix} \\mu_1 \\\\ \\mu_2 \\end{bmatrix}, \\quad \\alpha = \\begin{bmatrix} \\alpha_{11} & \\alpha_{12} \\\\ \\alpha_{21} & \\alpha_{22} \\end{bmatrix}, \\quad \\beta =  \\begin{bmatrix} \\beta_{11} & \\beta_{12} \\\\ \\beta_{21} & \\beta_{22} \\end{bmatrix} rmark random number generating function marks used non-mark models. lambda_component0 2--2 matrix represents initial values lambda_component, includes set values lambda11, lambda12, lambda21, lambda22. intensity processes represented λ1(t)=μ1+λ11(t)+λ12(t), \\lambda_1(t) = \\mu_1 + \\lambda_{11}(t) + \\lambda_{12}(t), λ2(t)=μ2+λ21(t)+λ22(t). \\lambda_2(t) = \\mu_2 + \\lambda_{21}(t) + \\lambda_{22}(t). terms λij\\lambda_{ij} referred lambda components, lambda0 represents $_{ij}(0).  parameterlambda_component0` can omitted model, case internally determined initial values used. perform simulation, use hsim function. multivariate models, type crucial represents type event. multivariate models, column names N N1, N2, N3, . Similarly, column names lambda lambda1, lambda2, lambda3, . column names lambda_component lambda_component11, lambda_component12, lambda_component13, . definition, following two expressions equivalent: results, obtain vectors realized inter_arrival type. bivariate model requires inter_arrival type estimation. log-likelihood computed using logLik function. Maximum log-likelihood estimation performed using hfit function. process, parameter values hspec0, mu, alpha, beta, serve starting points numerical optimization. illustration purposes, set hspec0 <- hspec2. Since true parameter values unknown practical applications, initial guesses used. realized inter_arrival type data utilized estimation.","code":"mu2 <- matrix(c(0.2), nrow = 2) alpha2 <- matrix(c(0.5, 0.9, 0.9, 0.5), nrow = 2, byrow = TRUE) beta2 <- matrix(c(2.25, 2.25, 2.25, 2.25), nrow = 2, byrow = TRUE) hspec2 <- new(\"hspec\", mu=mu2, alpha=alpha2, beta=beta2) print(hspec2) #> An object of class \"hspec\" of 2-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,]  0.2 #> [2,]  0.2 #>  #> Slot alpha:  #>      [,1] [,2] #> [1,]  0.5  0.9 #> [2,]  0.9  0.5 #>  #> Slot beta:  #>      [,1] [,2] #> [1,] 2.25 2.25 #> [2,] 2.25 2.25 set.seed(1107) res2 <- hsim(hspec2,  size=1000) summary(res2) #> ------------------------------------------------------- #> Simulation result of exponential (marked) Hawkes model. #> Realized path : #>       arrival N1 N2 mark lambda1 lambda2 #>  [1,] 0.00000  0  0    0 0.52941 0.52941 #>  [2,] 0.57028  1  0    1 0.29130 0.29130 #>  [3,] 1.66175  1  1    1 0.25073 0.28505 #>  [4,] 2.17979  1  2    1 0.49638 0.38238 #>  [5,] 2.47685  1  3    1 0.81319 0.54975 #>  [6,] 2.64001  2  3    1 1.24825 0.78866 #>  [7,] 2.70249  3  3    1 1.54519 1.49341 #>  [8,] 2.94547  4  3    1 1.26810 1.46968 #>  [9,] 3.39313  4  4    1 0.77271 0.99242 #> [10,] 3.52533  4  5    1 1.29379 1.15989 #> [11,] 3.56971  5  5    1 2.00432 1.52115 #> [12,] 3.70761  5  6    1 1.88965 1.82866 #> [13,] 4.30122  5  7    1 0.88106 0.75983 #> [14,] 4.34337  6  7    1 1.63800 1.16393 #> [15,] 4.40222  7  7    1 1.89764 1.83275 #> [16,] 4.58943  8  7    1 1.64219 1.86211 #> [17,] 5.14665  9  7    1 0.75437 0.93131 #> [18,] 5.18186  9  8    1 1.17407 1.70707 #> [19,] 5.36167  9  9    1 1.45050 1.53925 #> [20,] 5.89118 10  9    1 0.85331 0.75875 #> ... with 980 more rows  #> ------------------------------------------------------- # Under bi-variate model, there are two types, 1 or 2. res2$type[1:10] #>  [1] 0 1 2 2 2 1 1 1 2 2 res2$N[1:3, ] #>      N1 N2 #> [1,]  0  0 #> [2,]  1  0 #> [3,]  1  1 res2$lambda[1:3, ] #>        lambda1   lambda2 #> [1,] 0.5294118 0.5294118 #> [2,] 0.2913028 0.2913028 #> [3,] 0.2507301 0.2850475 res2$lambda_component[1:3, ] #>        lambda11    lambda12   lambda21    lambda22 #> [1,] 0.11764706 0.211764706 0.21176471 0.117647059 #> [2,] 0.03260813 0.058694641 0.05869464 0.032608134 #> [3,] 0.04569443 0.005035631 0.08224997 0.002797573 mu2[1] + rowSums(res2$lambda_component[1:5, c(\"lambda11\", \"lambda12\")]) #> [1] 0.5294118 0.2913028 0.2507301 0.4963769 0.8131889 res2$lambda[1:5, \"lambda1\"] #> [1] 0.5294118 0.2913028 0.2507301 0.4963769 0.8131889 inter_arrival2 <- res2$inter_arrival type2 <- res2$type logLik(hspec2, inter_arrival = inter_arrival2, type = type2) #> The initial values for intensity processes are not provided. Internally determined initial values are used. #> loglikelihood  #>     -974.2809 hspec0 <- hspec2 mle <- hfit(hspec0, inter_arrival = inter_arrival2, type = type2) summary(mle) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 36 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -970.1408  #> 4  free parameters #> Estimates: #>          Estimate Std. error t value  Pr(> t)     #> mu1       0.19095    0.01636  11.671  < 2e-16 *** #> alpha1.1  0.48217    0.07405   6.511 7.45e-11 *** #> alpha1.2  0.98625    0.09495  10.387  < 2e-16 *** #> beta1.1   2.07987    0.16952  12.269  < 2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> -------------------------------------------- coef(mle) #>       mu1  alpha1.1  alpha1.2   beta1.1  #> 0.1909541 0.4821725 0.9862542 2.0798691 miscTools::stdEr(mle) #>        mu1   alpha1.1   alpha1.2    beta1.1  #> 0.01636127 0.07405118 0.09495461 0.16952428"},{"path":[]},{"path":"https://ksublee.github.io/emhawkes/articles/extended_example.html","id":"univariate-hawkes-process","dir":"Articles","previous_headings":"Basic Hawkes model","what":"Univariate Hawkes process","title":"Extended example : emhawkes package","text":"subsection outlines steps constructing, running simulations, estimating univariate Hawkes model. begin, create hspec object, defines Hawkes model. S4 class hspec contains slots model parameters: mu, alpha, beta, dimens, rmark, impact. univariate model, basic parameters model—mu, alpha, beta—can given numeric values. numeric values provided, converted matrices. example univariate Hawkes model without mark. function hsim implements simulation input arguments hspec, size, initial values intensity component process, lambda_component0, initial values Hawkes processes, N0. precisely, intensity process basic univariate Hawkes model represented λ(t)=μ+∫−∞tαe−β(t−s)dN(s)=μ+λc(0)e−βt+∫0tαe−β(t−s)dN(s) \\lambda(t) = \\mu + \\int_{-\\infty}^t \\alpha e^{-\\beta (t-s)} d N(s) = \\mu + \\lambda_c(0) e^{-\\beta t} + \\int_0^t \\alpha e^{-\\beta (t-s)} d N(s) lambda_component0 denotes λc(0)=∫−∞0αeβsdN(s). \\lambda_c(0) = \\int_{-\\infty}^0 \\alpha e^{\\beta s} d N(s). lambda_component0 provided, internally determined initial values intensity process used. size sufficiently large, exact value lambda_component0 may important. default initial value counting process, N0, zero. results hsim S3 class hreal, consists hspec, inter_arrival, arrival, type, mark, N, Nc, lambda, lambda_component, rambda, rambda_component. hspec model specification. inter_arrival inter-arrival time every event. arrival cumulative sum inter_arrival. type type events, .e., ii NiN_i, used multivariate model. mark numeric vector represents additional information event. lambda represents λ\\lambda, left continuous right limit version. right continuous version intensity rambda. lambda_component represents λij\\lambda_{ij}, rambda_component right continuous version. inter_arrival, type, mark, N, Nc start zero. Using summary() function, one can print first 20 elements arrival, N, lambda. print() function can also used. definition, lambda == mu + lambda_component. rows except first, rambda equals lambda + alpha model. Additionally, verify exponential decay accurately represented model. log-likelihood function calculated using logLik method. context, inter-arrival times hspec provided inputs function. likelihood estimation performed using hfit function. specification initial parameter values, hspec0, required. Note inter_arrival needed univariate model. accurate simulation, recommended specify lambda0, initial value lambda component. lambda0 provided, function uses internally determined initial values. default, BFGS method employed numerical optimization.","code":"library(emhawkes) mu1 <- 0.3; alpha1 <- 1.2; beta1 <- 1.5 hspec1 <- new(\"hspec\", mu = mu1, alpha = alpha1, beta = beta1) show(hspec1) #> An object of class \"hspec\" of 1-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,]  0.3 #>  #> Slot alpha:  #>      [,1] #> [1,]  1.2 #>  #> Slot beta:  #>      [,1] #> [1,]  1.5 set.seed(1107) res1 <- hsim(hspec1, size = 1000) summary(res1) #> ------------------------------------------------------- #> Simulation result of exponential (marked) Hawkes model. #> Realized path : #>        arrival N1 mark lambda1 #>  [1,]  0.00000  0    0 0.90000 #>  [2,]  0.97794  1    1 0.43838 #>  [3,]  1.09001  2    1 1.43128 #>  [4,]  1.28999  3    1 2.02711 #>  [5,]  1.53225  4    1 2.33527 #>  [6,]  1.65001  5    1 3.01139 #>  [7,]  2.51807  6    1 1.36377 #>  [8,]  2.81710  7    1 1.74553 #>  [9,]  2.87547  8    1 2.72378 #> [10,]  3.16415  9    1 2.65016 #> [11,]  3.51378 10    1 2.40131 #> [12,]  4.22355 11    1 1.43843 #> [13,] 16.96752 12    1 0.30000 #> [14,] 17.71654 13    1 0.69015 #> [15,] 19.10293 14    1 0.49874 #> [16,] 24.06354 15    1 0.30082 #> [17,] 24.09256 16    1 1.44967 #> [18,] 28.40173 17    1 0.30366 #> [19,] 28.53743 18    1 1.28198 #> [20,] 28.56702 19    1 2.38725 #> ... with 980 more rows  #> ------------------------------------------------------- # first and third columns are the same cbind(res1$lambda[1:5], res1$lambda_component[1:5], mu1 + res1$lambda_component[1:5]) #>          [,1]     [,2]     [,3] #> [1,] 0.900000 0.600000 0.900000 #> [2,] 0.438383 0.138383 0.438383 #> [3,] 1.431282 1.131282 1.431282 #> [4,] 2.027111 1.727111 2.027111 #> [5,] 2.335269 2.035269 2.335269 # second and third columns are the same cbind(res1$lambda[1:5], res1$rambda[1:5], res1$lambda[1:5] + alpha1) #>          [,1]     [,2]     [,3] #> [1,] 0.900000 0.900000 2.100000 #> [2,] 0.438383 1.638383 1.638383 #> [3,] 1.431282 2.631282 2.631282 #> [4,] 2.027111 3.227111 3.227111 #> [5,] 2.335269 3.535269 3.535269 # By definition, the following two are equal: res1$lambda[2:6] #> [1] 0.438383 1.431282 2.027111 2.335269 3.011391 mu1 + (res1$rambda[1:5] - mu1) * exp(-beta1 * res1$inter_arrival[2:6]) #> [1] 0.438383 1.431282 2.027111 2.335269 3.011391 logLik(hspec1, inter_arrival = res1$inter_arrival) #> The initial values for intensity processes are not provided. Internally determined initial values are used. #> loglikelihood  #>     -214.2385 # initial value for numerical optimization mu0 <- 0.5; alpha0 <- 1.0; beta0 <- 1.8 hspec0 <- new(\"hspec\", mu = mu0, alpha = alpha0, beta = beta0) # the intial values are provided through hspec mle <- hfit(hspec0, inter_arrival = res1$inter_arrival) summary(mle) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 24 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -213.4658  #> 3  free parameters #> Estimates: #>        Estimate Std. error t value Pr(> t)     #> mu1     0.33641    0.03475   9.682  <2e-16 *** #> alpha1  1.16654    0.09608  12.141  <2e-16 *** #> beta1   1.52270    0.12468  12.213  <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> --------------------------------------------"},{"path":"https://ksublee.github.io/emhawkes/articles/extended_example.html","id":"bivariate-hawkes-model","dir":"Articles","previous_headings":"Basic Hawkes model","what":"Bivariate Hawkes model","title":"Extended example : emhawkes package","text":"intensity process basic bivariate Hawkes model defined λ1(t)=μ1+∫−∞tα11e−β11(t−s)dN1(s)+∫−∞tα12e−β12(t−s)dN2(s),  \\lambda_1(t) = \\mu_1 + \\int_{-\\infty}^t \\alpha_{11} e^{-\\beta_{11}(t-s)} d N_1(s) + \\int_{-\\infty}^t \\alpha_{12} e^{-\\beta_{12}(t-s)} d N_2(s), λ2(t)=μ2+∫−∞tα21e−β21(t−s)dN1(s)+∫−∞tα22e−β22(t−s)dN2(s).  \\lambda_2(t) = \\mu_2 + \\int_{-\\infty}^t \\alpha_{21} e^{-\\beta_{21}(t-s)} d N_1(s) + \\int_{-\\infty}^t \\alpha_{22} e^{-\\beta_{22}(t-s)} d N_2(s). bivariate model, parameters within slots hspec matrices. Specifically, mu 2--1 matrix, alpha beta 2--2 matrices. μ=[μ1μ2],α=[α11α12α21α22],β=[β11β12β21β22] \\mu = \\begin{bmatrix} \\mu_1 \\\\ \\mu_2 \\end{bmatrix}, \\quad \\alpha = \\begin{bmatrix} \\alpha_{11} & \\alpha_{12} \\\\ \\alpha_{21} & \\alpha_{22} \\end{bmatrix}, \\quad \\beta =  \\begin{bmatrix} \\beta_{11} & \\beta_{12} \\\\ \\beta_{21} & \\beta_{22} \\end{bmatrix} rmark random number generating function marks used non-mark models. lambda_component0 2--2 matrix represents initial values lambda_component, includes set values lambda11, lambda12, lambda21, lambda22. intensity processes represented λ1(t)=μ1+λ11(t)+λ12(t), \\lambda_1(t) = \\mu_1 + \\lambda_{11}(t) + \\lambda_{12}(t), λ2(t)=μ2+λ21(t)+λ22(t). \\lambda_2(t) = \\mu_2 + \\lambda_{21}(t) + \\lambda_{22}(t). terms λij\\lambda_{ij} referred lambda components, lambda0 represents $_{ij}(0).  parameterlambda_component0` can omitted model, case internally determined initial values used. perform simulation, use hsim function. multivariate models, type crucial represents type event. multivariate models, column names N N1, N2, N3, . Similarly, column names lambda lambda1, lambda2, lambda3, . column names lambda_component lambda_component11, lambda_component12, lambda_component13, . definition, following two expressions equivalent: results, obtain vectors realized inter_arrival type. bivariate model requires inter_arrival type estimation. log-likelihood computed using logLik function. Maximum log-likelihood estimation performed using hfit function. process, parameter values hspec0, mu, alpha, beta, serve starting points numerical optimization. illustration purposes, set hspec0 <- hspec2. Since true parameter values unknown practical applications, initial guesses used. realized inter_arrival type data utilized estimation.","code":"mu2 <- matrix(c(0.2), nrow = 2) alpha2 <- matrix(c(0.5, 0.9, 0.9, 0.5), nrow = 2, byrow = TRUE) beta2 <- matrix(c(2.25, 2.25, 2.25, 2.25), nrow = 2, byrow = TRUE) hspec2 <- new(\"hspec\", mu=mu2, alpha=alpha2, beta=beta2) print(hspec2) #> An object of class \"hspec\" of 2-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,]  0.2 #> [2,]  0.2 #>  #> Slot alpha:  #>      [,1] [,2] #> [1,]  0.5  0.9 #> [2,]  0.9  0.5 #>  #> Slot beta:  #>      [,1] [,2] #> [1,] 2.25 2.25 #> [2,] 2.25 2.25 set.seed(1107) res2 <- hsim(hspec2,  size=1000) summary(res2) #> ------------------------------------------------------- #> Simulation result of exponential (marked) Hawkes model. #> Realized path : #>       arrival N1 N2 mark lambda1 lambda2 #>  [1,] 0.00000  0  0    0 0.52941 0.52941 #>  [2,] 0.57028  1  0    1 0.29130 0.29130 #>  [3,] 1.66175  1  1    1 0.25073 0.28505 #>  [4,] 2.17979  1  2    1 0.49638 0.38238 #>  [5,] 2.47685  1  3    1 0.81319 0.54975 #>  [6,] 2.64001  2  3    1 1.24825 0.78866 #>  [7,] 2.70249  3  3    1 1.54519 1.49341 #>  [8,] 2.94547  4  3    1 1.26810 1.46968 #>  [9,] 3.39313  4  4    1 0.77271 0.99242 #> [10,] 3.52533  4  5    1 1.29379 1.15989 #> [11,] 3.56971  5  5    1 2.00432 1.52115 #> [12,] 3.70761  5  6    1 1.88965 1.82866 #> [13,] 4.30122  5  7    1 0.88106 0.75983 #> [14,] 4.34337  6  7    1 1.63800 1.16393 #> [15,] 4.40222  7  7    1 1.89764 1.83275 #> [16,] 4.58943  8  7    1 1.64219 1.86211 #> [17,] 5.14665  9  7    1 0.75437 0.93131 #> [18,] 5.18186  9  8    1 1.17407 1.70707 #> [19,] 5.36167  9  9    1 1.45050 1.53925 #> [20,] 5.89118 10  9    1 0.85331 0.75875 #> ... with 980 more rows  #> ------------------------------------------------------- # Under bi-variate model, there are two types, 1 or 2. res2$type[1:10] #>  [1] 0 1 2 2 2 1 1 1 2 2 res2$N[1:3, ] #>      N1 N2 #> [1,]  0  0 #> [2,]  1  0 #> [3,]  1  1 res2$lambda[1:3, ] #>        lambda1   lambda2 #> [1,] 0.5294118 0.5294118 #> [2,] 0.2913028 0.2913028 #> [3,] 0.2507301 0.2850475 res2$lambda_component[1:3, ] #>        lambda11    lambda12   lambda21    lambda22 #> [1,] 0.11764706 0.211764706 0.21176471 0.117647059 #> [2,] 0.03260813 0.058694641 0.05869464 0.032608134 #> [3,] 0.04569443 0.005035631 0.08224997 0.002797573 mu2[1] + rowSums(res2$lambda_component[1:5, c(\"lambda11\", \"lambda12\")]) #> [1] 0.5294118 0.2913028 0.2507301 0.4963769 0.8131889 res2$lambda[1:5, \"lambda1\"] #> [1] 0.5294118 0.2913028 0.2507301 0.4963769 0.8131889 inter_arrival2 <- res2$inter_arrival type2 <- res2$type logLik(hspec2, inter_arrival = inter_arrival2, type = type2) #> The initial values for intensity processes are not provided. Internally determined initial values are used. #> loglikelihood  #>     -974.2809 hspec0 <- hspec2 mle <- hfit(hspec0, inter_arrival = inter_arrival2, type = type2) summary(mle) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 36 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -970.1408  #> 4  free parameters #> Estimates: #>          Estimate Std. error t value  Pr(> t)     #> mu1       0.19095    0.01636  11.671  < 2e-16 *** #> alpha1.1  0.48217    0.07405   6.511 7.45e-11 *** #> alpha1.2  0.98625    0.09495  10.387  < 2e-16 *** #> beta1.1   2.07987    0.16952  12.269  < 2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> -------------------------------------------- coef(mle) #>       mu1  alpha1.1  alpha1.2   beta1.1  #> 0.1909541 0.4821725 0.9862542 2.0798691 miscTools::stdEr(mle) #>        mu1   alpha1.1   alpha1.2    beta1.1  #> 0.01636127 0.07405118 0.09495461 0.16952428"},{"path":"https://ksublee.github.io/emhawkes/articles/extended_example.html","id":"parameter-setting","dir":"Articles","previous_headings":"Basic Hawkes model","what":"Parameter setting","title":"Extended example : emhawkes package","text":"subsection explores relationship parameter settings estimation procedure multivariate Hawkes model. number parameters estimated model influenced configure parameter slots mu, alpha, beta hspec0, specifies initial values. Since parameter slot alpha matrix, elements can either different. Consequently, number parameters estimated varies depending whether initial settings identical distinct elements. example, alpha[1,1] alpha[1,2] hspec0 initially set different values, numerical procedure estimate alpha[1,1] alpha[1,2] separately. Conversely, alpha[1,1] alpha[1,2] initial setting, estimation procedure treats parameters identical model, thus estimating one value. Recall example previous section features symmetric Hawkes model, matrix alpha symmetric elements beta identical. first estimation example, initial value alpha0 matrix elements set value 0.75. configuration, hfit assumes alpha11, alpha12, alpha21, alpha22 identical model, even actual parameters different values. Similarly, parameter matrices mu0 beta0 treated manner. Note result, alpha1.1 falls somewhere original values alpha1.1 = 0.5 alpha1.2 = 0.9. following second example, elements alpha0 identical symmetric, reflecting original values used simulation. Specifically, alpha11 == alpha22 alpha12 == alpha21 alpha0, alpha11 alpha12 estimated differently. third example, estimation performed assumption mu1 mu2 may differ, even though original model. setting reduced = FALSE, parameters estimated. logic applies higher-dimensional models.","code":"print(hspec2) #> An object of class \"hspec\" of 2-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,]  0.2 #> [2,]  0.2 #>  #> Slot alpha:  #>      [,1] [,2] #> [1,]  0.5  0.9 #> [2,]  0.9  0.5 #>  #> Slot beta:  #>      [,1] [,2] #> [1,] 2.25 2.25 #> [2,] 2.25 2.25 set.seed(1107) res2 <- hsim(hspec2, size = 1000) mu0 <- matrix(c(0.15, 0.15), nrow = 2) alpha0 <- matrix(c(0.75, 0.75, 0.75, 0.75), nrow = 2, byrow=TRUE) beta0 <- matrix(c(2.6, 2.6, 2.6, 2.6), nrow = 2, byrow=TRUE)  hspec0 <- new(\"hspec\", mu=mu0, alpha=alpha0, beta=beta0) summary(hfit(hspec0, inter_arrival = res2$inter_arrival, type = res2$type)) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 44 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -979.5687  #> 3  free parameters #> Estimates: #>          Estimate Std. error t value Pr(> t)     #> mu1       0.19125    0.01636   11.69  <2e-16 *** #> alpha1.1  0.73981    0.05951   12.43  <2e-16 *** #> beta1.1   2.09707    0.16524   12.69  <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> -------------------------------------------- mu0 <- matrix(c(0.15, 0.15), nrow = 2) alpha0 <- matrix(c(0.75, 0.751, 0.751, 0.75), nrow = 2, byrow=TRUE) beta0 <- matrix(c(2.6, 2.6, 2.6, 2.6), nrow = 2, byrow=TRUE)  hspec0 <- new(\"hspec\", mu=mu0, alpha=alpha0, beta=beta0) summary(hfit(hspec0, inter_arrival = res2$inter_arrival, type = res2$type)) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 30 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -970.1408  #> 4  free parameters #> Estimates: #>          Estimate Std. error t value Pr(> t)     #> mu1       0.19095    0.01653  11.555 < 2e-16 *** #> alpha1.1  0.48226    0.07572   6.369 1.9e-10 *** #> alpha1.2  0.98626    0.09869   9.993 < 2e-16 *** #> beta1.1   2.08008    0.18449  11.275 < 2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> -------------------------------------------- mu0 <- matrix(c(0.15, 0.14), nrow = 2) alpha0 <- matrix(c(0.75, 0.751, 0.751, 0.75), nrow = 2, byrow=TRUE) beta0 <- matrix(c(2.6, 2.6, 2.6, 2.6), nrow = 2, byrow=TRUE)  hspec0 <- new(\"hspec\", mu=mu0, alpha=alpha0, beta=beta0) summary(hfit(hspec0, inter_arrival = res2$inter_arrival, type = res2$type)) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 42 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -969.9914  #> 5  free parameters #> Estimates: #>          Estimate Std. error t value  Pr(> t)     #> mu1       0.18300    0.02154   8.495  < 2e-16 *** #> mu2       0.19872    0.02203   9.020  < 2e-16 *** #> alpha1.1  0.48149    0.07425   6.484 8.91e-11 *** #> alpha1.2  0.98720    0.09556  10.331  < 2e-16 *** #> beta1.1   2.07973    0.17094  12.166  < 2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> -------------------------------------------- summary(hfit(hspec2, inter_arrival = res2$inter_arrival, type = res2$type, reduced=FALSE)) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 51 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -966.5055  #> 10  free parameters #> Estimates: #>          Estimate Std. error t value  Pr(> t)     #> mu1       0.17997    0.02312   7.784 7.05e-15 *** #> mu2       0.20060    0.02442   8.214  < 2e-16 *** #> alpha1.1  0.44726    0.16627   2.690  0.00714 **  #> alpha2.1  1.17743    0.22909   5.140 2.75e-07 *** #> alpha1.2  0.97048    0.14242   6.814 9.47e-12 *** #> alpha2.2  0.48979    0.15398   3.181  0.00147 **  #> beta1.1   2.52210    1.16375   2.167  0.03022 *   #> beta2.1   3.15498    0.67702   4.660 3.16e-06 *** #> beta1.2   1.80167    0.25695   7.012 2.35e-12 *** #> beta2.2   1.51338    0.54476   2.778  0.00547 **  #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> --------------------------------------------"},{"path":"https://ksublee.github.io/emhawkes/articles/extended_example.html","id":"residual-process","dir":"Articles","previous_headings":"Basic Hawkes model","what":"Residual process","title":"Extended example : emhawkes package","text":"residual process can extracted using logLik() function setting infer = TRUE. option enabled, logLik function returns list includes log-likelihood, inferred intensities, residual process. Note inference based object passed logLik function. returned object, res_process1 represents residual process.  practical scenarios, parameter values usually unknown, model may estimated computing residual processes.  nn-dimensional model, can compute residuals similar manner. case, object returned logLik function contains nn residual processes. example, following code, infer_res2$res_process1 infer_res2$res_process2 represent residual processes type.","code":"hrp <- new(\"hspec\", mu = 0.3, alpha = 1.2, beta = 1.5) res_rp <- hsim(hrp, size = 1000)  # inferred result infered_res <- logLik(hrp, res_rp$inter_arrival, infer = TRUE)  ## QQ-plot p <- ppoints(100) q <- quantile(infered_res$res_process1, p = p) plot(qexp(p), q, xlab=\"Theoretical Quantiles\",ylab=\"Sample Quantiles\") qqline(q, distribution=qexp,col=\"blue\", lty=2) # estimation mle_rp <- hfit(new(\"hspec\", mu = 0.2, alpha = 1, beta = 2),                res_rp$inter_arrival)  # construct hspec from estimation result he <- new(\"hspec\", mu = coef(mle_rp)[\"mu1\"],            alpha = coef(mle_rp)[\"alpha1\"], beta = coef(mle_rp)[\"beta1\"])  # infer intensity infered_res <- logLik(he, res_rp$inter_arrival, res_rp$type, infer = TRUE)  rpe <- infered_res$res_process1  p <- ppoints(100) q <- quantile(rpe, p=p) plot(qexp(p), q, xlab=\"Theoretical Quantiles\",ylab=\"Sample Quantiles\") qqline(q, distribution=qexp,col=\"blue\", lty=2) hrp2 <- new(\"hspec\", mu = rep(0.3, 2),             alpha = matrix(c(1.2, 1.5, 1.5, 1.2), nrow=2),             beta = matrix(rep(3, 4), nrow=2)) res_hrp2 <- hsim(hrp2, size = 2000)  infer_res2 <- logLik(hrp2, res_hrp2$inter_arrival, res_hrp2$type, infer = TRUE)  p <- ppoints(100) q <- quantile(c(infer_res2$res_process1, infer_res2$res_process2), p=p) plot(qexp(p), q, xlab=\"Theoretical Quantiles\",ylab=\"Sample Quantiles\") qqline(q, distribution=qexp,col=\"blue\", lty=2) # Infer the residual process using the log-likelihood method # 'infer_res_dh1' contains the inferred process data based on the inter-arrival times  hist(   c(infer_res2$res_process1, infer_res2$res_process2),   breaks = 50,   probability = TRUE,   main = \"Histogram of Inferred Residual Process\",   xlab = \"Residual Value\",   ylab = \"Density\" )  x <- seq(0, 8, 0.1)  lines(   x,   dexp(x),   col = 'red',   lwd = 2 )  legend(\"topright\", legend = \"Theoretical PDF\", col = \"red\", lwd = 2)"},{"path":[]},{"path":"https://ksublee.github.io/emhawkes/articles/extended_example.html","id":"multi-kernel-model","dir":"Articles","previous_headings":"More complicated model","what":"Multi-kernel model","title":"Extended example : emhawkes package","text":"multi-kernel Hawkes model, type_col_map required hspec. type_col_map list represents mapping type column number. example, consider bi-variate multi-kernel model: λt=μ+∫−∞th(t−u)dN(u) \\lambda_t = \\mu + \\int_{-\\infty}^{t} h(t-u) d N(u)  h=∑k=1Khk,hk(t)=αk∘[e−βk11te−βk12te−βk21te−βk22t] h = \\sum_{k=1}^{K} h_k, \\quad  h_k (t) = \\alpha_k \\circ \\begin{bmatrix} e^{-\\beta_{k11} t} & e^{-\\beta_{k12} t} \\\\ e^{-\\beta_{k21} t} & e^{-\\beta_{k22} t} \\end{bmatrix} matrix αk\\alpha_k kk denoting kernel number. example, bi-variate Hawkes model two kernels, intensity processes [λ1(t)λ2(t)]=[μ1μ2]+∫−∞t[α111e−β111tα112e−β112tα121e−β121tα122e−β122t][dN1(s)dN2(s)]+∫−∞t[α211e−β211tα212e−β212tα221e−β221tα222e−β222t][dN1(s)dN2(s)].  \\begin{bmatrix} \\lambda_1(t) \\\\ \\lambda_2(t) \\end{bmatrix} =  \\begin{bmatrix} \\mu_1 \\\\ \\mu_2 \\end{bmatrix} + \\int_{-\\infty}^{t} \\begin{bmatrix} \\alpha_{111} e^{-\\beta_{111} t} & \\alpha_{112} e^{-\\beta_{112} t} \\\\ \\alpha_{121}e^{-\\beta_{121} t} & \\alpha_{122}e^{-\\beta_{122} t} \\end{bmatrix} \\begin{bmatrix} d N_1(s) \\\\ dN_2(s) \\end{bmatrix}  + \\int_{-\\infty}^{t} \\begin{bmatrix} \\alpha_{211} e^{-\\beta_{211} t} & \\alpha_{212} e^{-\\beta_{212} t} \\\\ \\alpha_{221}e^{-\\beta_{221} t} & \\alpha_{222}e^{-\\beta_{222} t} \\end{bmatrix} \\begin{bmatrix} d N_1(s) \\\\ dN_2(s) \\end{bmatrix}. parameter matrix defined α=[α111α112α211α212α121α122α221α222],β=[β111β112β211β212β121β122β221β222]  \\alpha = \\begin{bmatrix} \\alpha_{111} & \\alpha_{112} & \\alpha_{211} & \\alpha_{212} \\\\ \\alpha_{121} & \\alpha_{122} & \\alpha_{221} & \\alpha_{222} \\end{bmatrix}, \\quad  \\beta = \\begin{bmatrix} \\beta_{111} & \\beta_{112} & \\beta_{211} & \\beta_{212} \\\\ \\beta_{121} & \\beta_{122} & \\beta_{221} & \\beta_{222} \\end{bmatrix} \\quad specify columns matrix associated NiN_i. Note dN1(s)d N_1(s) multiplied first third columns α\\alpha dN2(s)dN_2(s) multiplied second fourth columns α\\alpha hence type_col_map type associated columns type_col_map[[]]. Thus, addition, lambda_component0 provided simulation estimation.","code":"mu <- matrix(c(0.02, 0.02), nrow=2)        beta_1 <- matrix(rep(10, 4), nrow=2)  beta_2 <- matrix(rep(1, 4), nrow=2) beta  <- cbind(beta_1, beta_2)        alpha_1 <- matrix(c(3, 2,                     2, 3), nrow=2, byrow=TRUE) alpha_2 <- matrix(c(0.3, 0.2,                     0.2, 0.3), nrow=2, byrow=TRUE) alpha <- cbind(alpha_1, alpha_2)  print(alpha) #>      [,1] [,2] [,3] [,4] #> [1,]    3    2  0.3  0.2 #> [2,]    2    3  0.2  0.3 type_col_map <- list(c(1,3),  # columns for dN1                      c(2,4))  # columns for dN2 type_col_map #> [[1]] #> [1] 1 3 #>  #> [[2]] #> [1] 2 4 cat(\"Part of alpha associated with N1: \\n\") #> Part of alpha associated with N1: alpha[, type_col_map[[1]]]  # associated with N1 #>      [,1] [,2] #> [1,]    3  0.3 #> [2,]    2  0.2 cat(\"Part of alpha associated with N2: \\n\") #> Part of alpha associated with N2: alpha[, type_col_map[[2]]]  # associated with N2 #>      [,1] [,2] #> [1,]    2  0.2 #> [2,]    3  0.3  cat(\"Part of beta associated with N1: \\n\") #> Part of beta associated with N1: beta[, type_col_map[[1]]]  # associated with N1 #>      [,1] [,2] #> [1,]   10    1 #> [2,]   10    1 cat(\"Part of beta associated with N2: \\n\") #> Part of beta associated with N2: beta[, type_col_map[[2]]]  # associated with N2 #>      [,1] [,2] #> [1,]   10    1 #> [2,]   10    1 h <- new(\"hspec\", mu = mu, alpha = alpha, beta=beta, type_col_map = type_col_map) h #> An object of class \"hspec\" of 2-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,] 0.02 #> [2,] 0.02 #>  #> Slot alpha:  #>      [,1] [,2] [,3] [,4] #> [1,]    3    2  0.3  0.2 #> [2,]    2    3  0.2  0.3 #>  #> Slot beta:  #>      [,1] [,2] [,3] [,4] #> [1,]   10   10    1    1 #> [2,]   10   10    1    1 #>  #> Slot type_col_map:  #> [[1]] #> [1] 1 3 #>  #> [[2]] #> [1] 2 4 set.seed(620) res_mk <- hsim(h, size = 3000,                 # for an illustration purpose                lambda_component0 = matrix(seq(1, 1.7, 0.1), nrow = 2))  res_mk #> ------------------------------------------------------- #> Simulation result of exponential (marked) Hawkes model. #> An object of class \"hspec\" of 2-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,] 0.02 #> [2,] 0.02 #>  #> Slot alpha:  #>      [,1] [,2] [,3] [,4] #> [1,]    3    2  0.3  0.2 #> [2,]    2    3  0.2  0.3 #>  #> Slot beta:  #>      [,1] [,2] [,3] [,4] #> [1,]   10   10    1    1 #> [2,]   10   10    1    1 #>  #> Slot type_col_map:  #> [[1]] #> [1] 1 3 #>  #> [[2]] #> [1] 2 4 #>  #>  #> Realized path : #>       arrival N1 N2 mark lambda1 lambda2  lambda11  lambda12 lambda13 lambda14 #>  [1,]  0.0000  0  0    0   5.220   5.620 1.0000000 1.200e+00   1.4000   1.6000 #>  [2,]  0.3339  1  0    1   2.247   2.397 0.0354893 4.259e-02   1.0026   1.1459 #>  [3,]  1.2043  1  1    1   1.046   1.064 0.0005036 7.065e-06   0.5455   0.4799 #>  [4,]  1.2103  2  1    1   3.122   4.182 0.0004743 1.884e+00   0.5423   0.6758 #>  [5,]  1.3704  3  1    1   2.299   2.302 0.6051446 3.799e-01   0.7176   0.5758 #>  [6,]  1.4098  3  2    1   4.238   3.474 2.4298143 2.561e-01   0.9783   0.5535 #>  [7,]  1.5416  3  3    1   2.793   2.894 0.6507825 6.043e-01   0.8575   0.6605 #>  [8,]  1.6639  3  4    1   2.498   2.919 0.1914158 7.660e-01   0.7588   0.7614 #>  [9,]  2.0338  3  5    1   1.282   1.454 0.0047375 6.846e-02   0.5242   0.6642 #> [10,]  2.1098  4  5    1   2.276   2.981 0.0022151 9.671e-01   0.4858   0.8009 #> [11,]  2.3626  5  5    1   1.569   1.623 0.2396920 7.722e-02   0.6103   0.6220 #> [12,]  2.7052  5  6    1   1.216   1.178 0.1053725 2.511e-03   0.6462   0.4416 #> [13,]  2.7692  5  7    1   2.339   2.939 0.0555568 1.056e+00   0.6062   0.6018 #> [14,]  2.9333  6  7    1   1.818   2.272 0.0107638 5.920e-01   0.5144   0.6804 #> [15,]  3.0063  7  7    1   3.146   2.862 1.4508962 2.853e-01   0.7571   0.6325 #> [16,]  3.3222  7  8    1   1.453   1.365 0.1889842 1.211e-02   0.7707   0.4612 #> [17,]  3.3779  7  9    1   2.636   3.241 0.1082998 1.153e+00   0.7290   0.6254 #> [18,]  3.4084  8  9    1   3.931   5.226 0.0798097 2.324e+00   0.7071   0.8006 #> [19,]  3.7871  8 10    1   1.380   1.425 0.0698539 5.270e-02   0.6897   0.5482 #> [20,]  3.8329  9 10    1   2.736   3.505 0.0441702 1.298e+00   0.6588   0.7147 #>        lambda21  lambda22 lambda23 lambda24 #>  [1,] 1.1000000 1.300e+00   1.5000   1.7000 #>  [2,] 0.0390382 4.614e-02   1.0742   1.2175 #>  [3,] 0.0003383 7.654e-06   0.5336   0.5098 #>  [4,] 0.0003186 2.826e+00   0.5304   0.8050 #>  [5,] 0.4034302 5.699e-01   0.6224   0.6859 #>  [6,] 1.6198765 3.841e-01   0.7906   0.6594 #>  [7,] 0.4338551 9.064e-01   0.6930   0.8410 #>  [8,] 0.1276106 1.149e+00   0.6132   1.0095 #>  [9,] 0.0031583 1.027e-01   0.4236   0.9046 #> [10,] 0.0014767 1.451e+00   0.3926   1.1165 #> [11,] 0.1597947 1.158e-01   0.4602   0.8671 #> [12,] 0.0702484 3.767e-03   0.4687   0.6156 #> [13,] 0.0370378 1.584e+00   0.4397   0.8588 #> [14,] 0.0071759 8.881e-01   0.3731   0.9834 #> [15,] 0.9672641 4.280e-01   0.5328   0.9142 #> [16,] 0.1259895 1.817e-02   0.5343   0.6665 #> [17,] 0.0721999 1.730e+00   0.5053   0.9142 #> [18,] 0.0532064 3.485e+00   0.4901   1.1777 #> [19,] 0.0465693 7.905e-02   0.4726   0.8065 #> [20,] 0.0294468 1.947e+00   0.4514   1.0569 #> ... with 2980 more rows  #> ------------------------------------------------------- summary(hfit(h, res_mk$inter_arrival, res_mk$type,              lambda_component0 = matrix(seq(1, 1.7, 0.1), nrow = 2))) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 77 iterations #> Return code 0: successful convergence  #> Log-Likelihood: 6084.72  #> 7  free parameters #> Estimates: #>          Estimate Std. error t value  Pr(> t)     #> mu1      0.011160   0.007537   1.481    0.139     #> alpha1.1 2.474055   0.206092  12.005  < 2e-16 *** #> alpha1.2 1.380731   0.220328   6.267 3.69e-10 *** #> alpha1.3 0.044029   0.071762   0.614    0.540     #> alpha1.4 0.231188   0.058453   3.955 7.65e-05 *** #> beta1.1  6.202489   0.077197  80.346  < 2e-16 *** #> beta1.3  0.700718   0.117474   5.965 2.45e-09 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> --------------------------------------------"},{"path":"https://ksublee.github.io/emhawkes/articles/extended_example.html","id":"synchronized-intensity-model","dir":"Articles","previous_headings":"More complicated model","what":"Synchronized intensity model","title":"Extended example : emhawkes package","text":"model basically two-kernel model defined little bit complicated reparameterization. μ=[θ/(1−κ)/2+θ̃/(1+κ)/2θ/(1−κ)/2−θ̃/(1+κ)/2],θ=(θ−+θ+)/2,θ̃=(θ−−θ+)/2  \\mu = \\begin{bmatrix} \\theta/(1 - \\kappa)/2 + \\tilde\\theta/(1 + \\kappa)/2 \\\\ \\theta/(1 - \\kappa)/2 - \\tilde\\theta/(1 + \\kappa)/2 \\end{bmatrix}, \\quad \\theta = (\\theta^- + \\theta^+)/2,\\quad \\tilde\\theta=(\\theta^- -\\theta^+)/2 α=[ζζ̃ζ−ζ̃ζ−ζ̃ζζ̃],ζ=(η+ν)/2,ζ̃=(η−ν)/2 \\alpha = \\begin{bmatrix} \\zeta & \\tilde\\zeta & \\zeta & -\\tilde\\zeta \\\\ \\zeta & -\\tilde\\zeta & \\zeta & \\tilde\\zeta \\end{bmatrix}, \\quad \\zeta = (\\eta + \\nu) / 2, \\quad \\tilde \\zeta = (\\eta - \\nu)/ 2 β=[β1β2β1β2β1β2β1β2],β1=(η+ν)/2,β2=(η−ν)/2 \\beta = \\begin{bmatrix} \\beta_1 & \\beta_2 & \\beta_1 & \\beta_2 \\\\ \\beta_1 & \\beta_2 & \\beta_1 & \\beta_2 \\end{bmatrix}, \\quad \\beta_1 = (\\eta + \\nu) / 2, \\quad \\beta_2 = (\\eta - \\nu)/2 order handle complex re-parametrization, slot expressed function rather matrix. first argument param set parameters. estimation based function arguments param. addition, initial values numerical optimization default values specified param. Note name arguments treated parameter. kappa mu beta, one kappa appears estimation result.","code":"mu <- function(param = c(theta_p = 0.15, theta_n = 0.21, kappa = 0.12)){   theta    <- (param[\"theta_n\"] + param[\"theta_p\"])/2   theta_tl <- (param[\"theta_n\"] - param[\"theta_p\"])/2   matrix(c(theta/2/(1 - param[\"kappa\"]) + theta_tl/2/(1 + param[\"kappa\"]),            theta/2/(1 - param[\"kappa\"]) - theta_tl/2/(1 + param[\"kappa\"])), nrow=2) }  alpha <- function(param = c(eta = 5, nu = 3)){   zeta    <- (param[\"eta\"] + param[\"nu\"])/2   zeta_tl <- (param[\"eta\"] - param[\"nu\"])/2   matrix(c(zeta, zeta_tl, zeta, -zeta_tl,            zeta, -zeta_tl, zeta, zeta_tl), nrow=2, byrow=TRUE) }  beta <- function(param = c(beta = 12, kappa = 0.12)){   beta1 <- param[\"beta\"] * (1 - param[\"kappa\"])   beta2 <- param[\"beta\"] * (1 + param[\"kappa\"])   matrix(c(beta1, beta2, beta1, beta2,            beta1, beta2, beta1, beta2), nrow = 2, byrow = TRUE) }  type_col_map <- list(c(1,2), c(3,4))  h_sy <- new(\"hspec\", mu = mu, alpha = alpha, beta = beta, type_col_map = type_col_map) h_sy #> An object of class \"hspec\" of 2-dimensional Hawkes process #>  #> Slot mu:  #> function (param = c(theta_p = 0.15, theta_n = 0.21, kappa = 0.12))  #> { #>     theta <- (param[\"theta_n\"] + param[\"theta_p\"])/2 #>     theta_tl <- (param[\"theta_n\"] - param[\"theta_p\"])/2 #>     matrix(c(theta/2/(1 - param[\"kappa\"]) + theta_tl/2/(1 + param[\"kappa\"]),  #>         theta/2/(1 - param[\"kappa\"]) - theta_tl/2/(1 + param[\"kappa\"])),  #>         nrow = 2) #> } #> <bytecode: 0x000001ddee3135e8> #>  #> Slot alpha:  #> function (param = c(eta = 5, nu = 3))  #> { #>     zeta <- (param[\"eta\"] + param[\"nu\"])/2 #>     zeta_tl <- (param[\"eta\"] - param[\"nu\"])/2 #>     matrix(c(zeta, zeta_tl, zeta, -zeta_tl, zeta, -zeta_tl, zeta,  #>         zeta_tl), nrow = 2, byrow = TRUE) #> } #> <bytecode: 0x000001dde7b5a578> #>  #> Slot beta:  #> function (param = c(beta = 12, kappa = 0.12))  #> { #>     beta1 <- param[\"beta\"] * (1 - param[\"kappa\"]) #>     beta2 <- param[\"beta\"] * (1 + param[\"kappa\"]) #>     matrix(c(beta1, beta2, beta1, beta2, beta1, beta2, beta1,  #>         beta2), nrow = 2, byrow = TRUE) #> } #> <bytecode: 0x000001ddec820938> #>  #> Slot type_col_map:  #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 3 4 set.seed(1107) # run simulation res_sy <- hsim(h_sy, size = 2000, lambda_component0 = matrix(rep(1, 2 * 4), nrow=2)) summary(res_sy) #> ------------------------------------------------------- #> Simulation result of exponential (marked) Hawkes model. #> Realized path : #>       arrival N1 N2 mark lambda1 lambda2 #>  [1,]  0.0000  0  0    0 4.11567 4.08888 #>  [2,]  7.2506  0  1    1 0.11567 0.08888 #>  [3,]  7.4805  0  2    1 0.42304 0.48724 #>  [4,]  7.4915  1  2    1 3.09049 4.86829 #>  [5,] 17.7981  2  2    1 0.11567 0.08888 #>  [6,] 20.0276  2  3    1 0.11567 0.08888 #>  [7,] 20.0484  2  4    1 2.56966 4.05419 #>  [8,] 20.0609  3  4    1 4.94847 7.88899 #>  [9,] 20.1607  4  4    1 3.58697 3.81330 #> [10,] 20.2304  5  4    1 4.09539 3.38445 #> [11,] 20.5057  5  5    1 0.56602 0.47289 #> [12,] 26.4862  6  5    1 0.11567 0.08888 #> [13,] 32.5114  6  6    1 0.11567 0.08888 #> [14,] 32.6227  6  7    1 1.12663 1.54804 #> [15,] 32.6316  6  8    1 3.79509 5.94053 #> [16,] 32.6480  7  8    1 5.81283 9.13210 #> [17,] 32.6921  7  9    1 6.87877 7.59586 #> [18,] 32.7953  8  9    1 3.51752 4.17621 #> [19,] 32.9249  8 10    1 2.20298 1.94570 #> [20,] 34.7648  9 10    1 0.11567 0.08888 #> ... with 1980 more rows  #> ------------------------------------------------------- fit_sy <- hfit(h_sy, inter_arrival=res_sy$inter_arrival,                 type=res_sy$type,                lambda_component0 = matrix(rep(1, 2 * 4), nrow=2)) summary(fit_sy) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 77 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -260.6273  #> 6  free parameters #> Estimates: #>         Estimate Std. error t value  Pr(> t)     #> theta_p  0.08291    0.01587   5.223 1.76e-07 *** #> theta_n  0.16264    0.01695   9.594  < 2e-16 *** #> kappa    0.40990    0.02294  17.866  < 2e-16 *** #> eta      5.23253    0.36946  14.163  < 2e-16 *** #> nu       2.89429    0.32969   8.779  < 2e-16 *** #> beta    18.01820        NaN     NaN      NaN     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> --------------------------------------------"},{"path":"https://ksublee.github.io/emhawkes/articles/extended_example.html","id":"extended-model","dir":"Articles","previous_headings":"","what":"Extended model","title":"Extended example : emhawkes package","text":"following family extended multi-variate marked Hawkes models implemented: λ(t)=μ+∫(−∞,t)×Eh(t,u,z)M(du×dz)  \\lambda(t) = \\mu + \\int_{(-\\infty,t)\\times E} h(t, u, z)M(du \\times dz) kernel hh represented h(t,u,z)=(α+g(t,z))Γ(t), h(t, u, z) = (\\alpha + g(t, z))\\Gamma(t), α\\alpha constant matrix, g(t,z)g(t, z) additional impacts intensities, may depend mark, information generated underlying processes, Γ(t)\\Gamma(t) exponential decaying matrix Γij(t)=e−βij(t)\\Gamma_{ij}(t) = e^{-\\beta_{ij}(t)}, MM denotes random measures defined product time mark spaces.","code":""},{"path":"https://ksublee.github.io/emhawkes/articles/extended_example.html","id":"linear-impact-model","dir":"Articles","previous_headings":"Extended model","what":"Linear impact model","title":"Extended example : emhawkes package","text":"linear impact model, g(t,z)=η(z−1).  g(t, z) = \\eta (z-1). impact represents Ψ(z)\\Psi(z), impact mark future intensity. details, see Marked Hawkes process modeling price dynamics volatility estimation. function, first argument param represents parameter model. impact() function can additional arguments related model specification generated path, n, mark, etc. miss ... ellipsis omitted, error occurs. rmark() function generate marks simulation. special case linear impact function, following implementation recommended. marked Hawkes model, additional linear impact can represented slot eta. model, intensity process λ(t)=μ+∫(−∞,t)×E(α+η(z−1))e−β(t−u)M(dt×dz).  \\lambda(t) = \\mu + \\int_{(-\\infty, t)\\times E} (\\alpha + \\eta (z-1)) e^{-\\beta(t-u)}  M(dt \\times dz). want estimate mark distribution also, dmark slot describes density function mark required.","code":"mu <- matrix(c(0.15, 0.15), nrow=2) alpha <- matrix(c(0.75, 0.6, 0.6, 0.75), nrow=2, byrow=T) beta <- matrix(c(2.6, 2.6, 2.6, 2.6), nrow=2) rmark <- function(param = c(p=0.65), ...){   rgeom(1, p=param[1]) + 1 }  impact <- function(param = c(eta1=0.2), alpha, n, mark, ...){   ma <- matrix(rep(mark[n]-1, 4), nrow = 2)   ma * matrix( rep(param[\"eta1\"], 4), nrow=2) }  hi <- new(\"hspec\", mu=mu, alpha=alpha, beta=beta,           rmark = rmark,           impact=impact) hi #> An object of class \"hspec\" of 2-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,] 0.15 #> [2,] 0.15 #>  #> Slot alpha:  #>      [,1] [,2] #> [1,] 0.75 0.60 #> [2,] 0.60 0.75 #>  #> Slot beta:  #>      [,1] [,2] #> [1,]  2.6  2.6 #> [2,]  2.6  2.6 #>  #> Slot impact:  #> function (param = c(eta1 = 0.2), alpha, n, mark, ...)  #> { #>     ma <- matrix(rep(mark[n] - 1, 4), nrow = 2) #>     ma * matrix(rep(param[\"eta1\"], 4), nrow = 2) #> } #>  #> Slot rmark:  #> function (param = c(p = 0.65), ...)  #> { #>     rgeom(1, p = param[1]) + 1 #> } set.seed(1107) res_impact <- hsim(hi, size=1000, lambda_component0 = matrix(rep(0.1,4), nrow=2)) summary(res_impact) #> ------------------------------------------------------- #> Simulation result of exponential (marked) Hawkes model. #> Realized path : #>       arrival N1 N2 mark lambda1 lambda2 #>  [1,]  0.0000  0  0    0 0.35000 0.35000 #>  [2,]  1.3001  0  1    1 0.15681 0.15681 #>  [3,]  2.5585  1  1    2 0.17302 0.17871 #>  [4,]  2.7982  1  2    1 0.67171 0.59433 #>  [5,]  3.0525  2  2    2 0.72904 0.76653 #>  [6,]  3.3929  3  2    1 0.78108 0.73464 #>  [7,]  3.4509  4  2    3 1.33764 1.16872 #>  [8,]  3.5101  5  2    2 2.15429 1.88085 #>  [9,]  3.5837  6  2    1 2.58987 2.24016 #> [10,]  3.6041  7  2    1 3.17455 2.70074 #> [11,]  3.7053  8  2    1 3.05159 2.57205 #> [12,]  3.9277  9  2    1 2.19788 1.84482 #> [13,]  3.9610 10  2    1 2.71584 2.25450 #> [14,]  4.2448 11  2    1 1.73576 1.44339 #> [15,]  4.7277 12  2    4 0.81551 0.68947 #> [16,]  5.1473 12  3    1 0.82698 0.73426 #> [17,]  5.3229 12  4    2 0.95877 0.99505 #> [18,]  5.4219 13  4    1 1.39371 1.53772 #> [19,]  5.4869 14  4    2 1.83388 1.82882 #> [20,]  5.8857 14  5    1 1.08385 1.02887 #> ... with 980 more rows  #> ------------------------------------------------------- fit <- hfit(hi,              inter_arrival = res_impact$inter_arrival,             type = res_impact$type,             mark = res_impact$mark,             lambda_component0 = matrix(rep(0.1,4), nrow=2))  summary(fit) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 38 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -1525.501  #> 5  free parameters #> Estimates: #>          Estimate Std. error t value Pr(> t)     #> mu1       0.13190    0.00891  14.804  <2e-16 *** #> alpha1.1  0.67609    0.07742   8.732  <2e-16 *** #> alpha1.2  0.60345    0.07211   8.368  <2e-16 *** #> beta1.1   2.22126    0.16730  13.277  <2e-16 *** #> eta1      0.11635    0.05549   2.097   0.036 *   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> -------------------------------------------- rmark <- function(param = c(p=0.65), ...){   rgeom(1, p=param[1]) + 1 }  h <-  new(\"hspec\", mu=0.15, alpha=0.7, beta=1.6, eta=0.3,           rmark = rmark) h #> An object of class \"hspec\" of 1-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,] 0.15 #>  #> Slot alpha:  #>      [,1] #> [1,]  0.7 #>  #> Slot beta:  #>      [,1] #> [1,]  1.6 #>  #> Slot eta:  #>      [,1] #> [1,]  0.3 #>  #> Slot rmark:  #> function (param = c(p = 0.65), ...)  #> { #>     rgeom(1, p = param[1]) + 1 #> } set.seed(1107) res <- hsim(h, size = 1000) summary(res) #> ------------------------------------------------------- #> Simulation result of exponential (marked) Hawkes model. #> Realized path : #>       arrival N1 mark lambda1 #>  [1,]  0.0000  0    0 0.20833 #>  [2,]  1.9559  1    1 0.15255 #>  [3,]  3.2143  2    1 0.24381 #>  [4,]  3.9750  3    1 0.38501 #>  [5,]  4.5731  4    1 0.50912 #>  [6,]  7.7740  5    1 0.15632 #>  [7,] 11.9290  6    2 0.15092 #>  [8,] 13.4270  7    1 0.24108 #>  [9,] 23.3482  8    1 0.15000 #> [10,] 31.9666  9    3 0.15000 #> [11,] 32.0257 10    2 1.33257 #> [12,] 32.1598 11    1 1.91124 #> [13,] 36.9851 12    1 0.15109 #> [14,] 37.1167 13    2 0.71795 #> [15,] 38.4261 14    1 0.34298 #> [16,] 38.9803 15    1 0.51792 #> [17,] 42.9827 16    2 0.15177 #> [18,] 48.4580 17    1 0.15016 #> [19,] 48.7737 18    1 0.57247 #> [20,] 48.7910 19    2 1.24194 #> ... with 980 more rows  #> ------------------------------------------------------- fit <- hfit(h,              inter_arrival = res$inter_arrival,             type = res$type,             mark = res$mark) summary(fit) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 37 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -1684.238  #> 4  free parameters #> Estimates: #>        Estimate Std. error t value  Pr(> t)     #> mu1     0.14557    0.00847  17.187  < 2e-16 *** #> alpha1  0.63917    0.06892   9.275  < 2e-16 *** #> beta1   1.48983    0.12320  12.092  < 2e-16 *** #> eta1    0.33626    0.07723   4.354 1.34e-05 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> -------------------------------------------- h_md <- h  h_md@dmark <- function(param = c(p = 0.1), n=n, mark=mark, ...){    dgeom(mark[n] - 1, prob = param[\"p\"]) }  mle_md <- hfit(h_md,                 inter_arrival = res$inter_arrival, type = res$type, mark = res$mark) summary(mle_md) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 46 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -2657.079  #> 5  free parameters #> Estimates: #>        Estimate Std. error t value  Pr(> t)     #> mu1    0.145574   0.008468  17.190  < 2e-16 *** #> alpha1 0.639168   0.069753   9.163  < 2e-16 *** #> beta1  1.489843   0.124301  11.986  < 2e-16 *** #> eta1   0.336259   0.076904   4.372 1.23e-05 *** #> p      0.658970   0.012203  54.002  < 2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> --------------------------------------------"},{"path":"https://ksublee.github.io/emhawkes/articles/extended_example.html","id":"hawkes-flocking-model","dir":"Articles","previous_headings":"Extended model","what":"Hawkes flocking model","title":"Extended example : emhawkes package","text":"function gg necessarily depend mark. Hawkes flocking model, kernel component represented α=[α11α1200α12α110000α33α3400α34α33], \\alpha = \\begin{bmatrix}\\alpha_{11} & \\alpha_{12} & 0 & 0 \\\\\\alpha_{12}& \\alpha_{11} & 0 & 0 \\\\0 & 0 & \\alpha_{33} & \\alpha_{34} \\\\0 & 0 & \\alpha_{34} & \\alpha_{33} \\end{bmatrix}, g=[00α1w1{C1(t)<C2(t)}α1n1{C1(t)<C2(t)}00α1n1{C1(t)>C2(t)}α1w1{C1(t)>C2(t)}α2w1{C2(t)<C1(t)}α2n1{C2(t)<C1(t)}00α2n1{C2(t)>C1(t)}α2w1{C2(t)>C1(t)}00],  g = \\begin{bmatrix} 0 & 0 & \\alpha_{1w} 1_{\\{C_1(t) < C_2(t)\\}} & \\alpha_{1n} 1_{\\{C_1(t) < C_2(t)\\}} \\\\  0 & 0 & \\alpha_{1n} 1_{\\{C_1(t) > C_2(t)\\}} & \\alpha_{1w}1_{\\{C_1(t) > C_2(t)\\}} \\\\ \\alpha_{2w} 1_{\\{C_2(t) < C_1(t)\\}} & \\alpha_{2n}1_{\\{C_2(t) < C_1(t)\\}} & 0 & 0 \\\\ \\alpha_{2n} 1_{\\{C_2(t) > C_1(t)\\}} & \\alpha_{2w}1_{\\{C_2(t) > C_1(t)\\}} & 0 & 0 \\end{bmatrix}, C1(t)=N1(t)−N2(t),C2(t)=N3(t)−N4(t). C_1(t) = N_1(t) - N_2(t), \\quad C_2(t) = N_3(t) - N_4(t).  details, see Systemic risk market microstructure crude oil gasoline futures prices: Hawkes flocking model approach. basic model, alpha matrix, can function following code. function alpha simply return 4×44\\times4 matrix , can fix elements specific vales estimating. estimating, optimization applied specified parameters argument param. case simulation, difference whether parameter set represented matrix function. impact() function little bit complicated, nothing expressing definition model R function. Note specify N=N, n=n argument. N counting process NN n denotes time step. needed implement function body required specify argument. … also omitted.","code":"mu <- matrix(c(0.02, 0.02, 0.04, 0.04), nrow = 4)   alpha <- function(param = c(alpha11 = 0.2, alpha12 = 0.3, alpha33 = 0.3, alpha34 = 0.4)){   matrix(c(param[\"alpha11\"], param[\"alpha12\"], 0, 0,            param[\"alpha12\"], param[\"alpha11\"], 0, 0,            0, 0, param[\"alpha33\"], param[\"alpha34\"],            0, 0, param[\"alpha34\"], param[\"alpha33\"]), nrow = 4, byrow = TRUE) }   beta <- matrix(c(rep(0.7, 8), rep(1.1, 8)), nrow = 4, byrow = TRUE) impact <- function(param = c(alpha1n=0.25, alpha1w=0.1, alpha2n=0.1, alpha2w=0.2),                    N=N, n=n, ...){      Psi <- matrix(c(0, 0, param['alpha1w'], param['alpha1n'],                   0, 0, param['alpha1n'], param['alpha1w'],                   param['alpha2w'], param['alpha2n'], 0, 0,                   param['alpha2n'], param['alpha2w'], 0, 0), nrow=4, byrow=TRUE)      ind <- N[,\"N1\"][n] - N[,\"N2\"][n] > N[,\"N3\"][n] - N[,\"N4\"][n]      km <- matrix(c(!ind, !ind, !ind, !ind,                  ind, ind, ind, ind,                  ind, ind, ind, ind,                  !ind, !ind, !ind, !ind), nrow = 4, byrow = TRUE)      km * Psi }  hspec_fl <- new(\"hspec\",                 mu = mu, alpha = alpha, beta = beta, impact = impact) hspec_fl #> An object of class \"hspec\" of 4-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,] 0.02 #> [2,] 0.02 #> [3,] 0.04 #> [4,] 0.04 #>  #> Slot alpha:  #> function (param = c(alpha11 = 0.2, alpha12 = 0.3, alpha33 = 0.3,  #>     alpha34 = 0.4))  #> { #>     matrix(c(param[\"alpha11\"], param[\"alpha12\"], 0, 0, param[\"alpha12\"],  #>         param[\"alpha11\"], 0, 0, 0, 0, param[\"alpha33\"], param[\"alpha34\"],  #>         0, 0, param[\"alpha34\"], param[\"alpha33\"]), nrow = 4,  #>         byrow = TRUE) #> } #> <bytecode: 0x000001ddee038ba0> #>  #> Slot beta:  #>      [,1] [,2] [,3] [,4] #> [1,]  0.7  0.7  0.7  0.7 #> [2,]  0.7  0.7  0.7  0.7 #> [3,]  1.1  1.1  1.1  1.1 #> [4,]  1.1  1.1  1.1  1.1 #>  #> Slot impact:  #> function (param = c(alpha1n = 0.25, alpha1w = 0.1, alpha2n = 0.1,  #>     alpha2w = 0.2), N = N, n = n, ...)  #> { #>     Psi <- matrix(c(0, 0, param[\"alpha1w\"], param[\"alpha1n\"],  #>         0, 0, param[\"alpha1n\"], param[\"alpha1w\"], param[\"alpha2w\"],  #>         param[\"alpha2n\"], 0, 0, param[\"alpha2n\"], param[\"alpha2w\"],  #>         0, 0), nrow = 4, byrow = TRUE) #>     ind <- N[, \"N1\"][n] - N[, \"N2\"][n] > N[, \"N3\"][n] - N[, \"N4\"][n] #>     km <- matrix(c(!ind, !ind, !ind, !ind, ind, ind, ind, ind,  #>         ind, ind, ind, ind, !ind, !ind, !ind, !ind), nrow = 4,  #>         byrow = TRUE) #>     km * Psi #> } set.seed(1107) hr_fl <- hsim(hspec_fl, size=2000) summary(hr_fl) #> ------------------------------------------------------- #> Simulation result of exponential (marked) Hawkes model. #> Realized path : #>        arrival N1 N2 N3 N4 mark  lambda1  lambda2  lambda3  lambda4 #>  [1,]  0.00000  0  0  0  0    0 0.070000 0.070000 0.110000 0.110000 #>  [2,]  0.84055  0  0  1  0    1 0.047761 0.047761 0.067768 0.067768 #>  [3,]  7.35095  0  0  2  0    1 0.021340 0.020291 0.040254 0.040332 #>  [4,]  8.74603  1  0  2  0    1 0.058165 0.020110 0.104718 0.126289 #>  [5,] 29.54186  2  0  2  0    1 0.020000 0.020000 0.040000 0.040000 #>  [6,] 30.90333  2  1  2  0    1 0.097114 0.135671 0.040000 0.062366 #>  [7,] 31.08275  3  1  2  0    1 0.352605 0.298414 0.040000 0.222539 #>  [8,] 33.42583  4  1  2  0    1 0.123299 0.132184 0.040000 0.061465 #>  [9,] 33.75532  5  1  2  0    1 0.260826 0.347283 0.179195 0.054939 #> [10,] 34.28018  6  1  2  0    1 0.325287 0.454414 0.230420 0.048387 #> [11,] 35.06698  6  2  2  0    1 0.311303 0.443397 0.204307 0.043530 #> [12,] 35.31209  6  3  2  0    1 0.518076 0.545110 0.241844 0.042695 #> [13,] 35.91748  6  4  2  0    1 0.542398 0.494637 0.195086 0.041385 #> [14,] 36.30025  7  4  2  0    1 0.649096 0.536065 0.141792 0.172180 #> [15,] 36.96094  7  5  2  0    1 0.542096 0.533891 0.185908 0.103906 #> [16,] 36.99520  7  5  2  1    1 0.822615 0.716974 0.180512 0.294145 #> [17,] 37.01805  8  5  2  1    1 0.809878 0.804326 0.567094 0.580389 #> [18,] 37.57785  9  5  2  1    1 0.688962 0.752790 0.432793 0.331931 #> [19,] 39.12437  9  5  2  2    1 0.314339 0.369832 0.148166 0.093268 #> [20,] 40.15404 10  5  2  2    1 0.163160 0.238789 0.203723 0.153817 #> ... with 1980 more rows  #> ------------------------------------------------------- fit_fl <- hfit(hspec_fl, hr_fl$inter_arrival, hr_fl$type) summary(fit_fl) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 84 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -3050.319  #> 12  free parameters #> Estimates: #>         Estimate Std. error t value  Pr(> t)     #> mu1     0.028055   0.004301   6.524 6.87e-11 *** #> mu3     0.033179   0.004262   7.784 7.02e-15 *** #> alpha11 0.199720   0.028740   6.949 3.68e-12 *** #> alpha12 0.312236   0.030169  10.349  < 2e-16 *** #> alpha33 0.283861   0.036653   7.745 9.59e-15 *** #> alpha34 0.341250   0.039297   8.684  < 2e-16 *** #> beta1.1 0.734703   0.052068  14.110  < 2e-16 *** #> beta3.1 0.899924   0.074849  12.023  < 2e-16 *** #> alpha1n 0.250338   0.044534   5.621 1.90e-08 *** #> alpha1w 0.107483   0.029787   3.608 0.000308 *** #> alpha2n 0.083683   0.037638   2.223 0.026191 *   #> alpha2w 0.172788   0.033958   5.088 3.61e-07 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> --------------------------------------------"},{"path":"https://ksublee.github.io/emhawkes/articles/extended_example.html","id":"bid-ask-price-model","dir":"Articles","previous_headings":"Extended model","what":"Bid-ask price model","title":"Extended example : emhawkes package","text":"model, use system counting processes corresponding conditional intensities describe bid-ask price processes: Nt=[N1(t)N2(t)N3(t)N4(t)],λt=[λ1(t)λ2(t)λ3(t)λ4(t)]  N_t = \\begin{bmatrix} N_1(t) \\\\ N_2(t) \\\\ N_3(t) \\\\ N_4(t) \\end{bmatrix}, \\quad \\lambda_t = \\begin{bmatrix} \\lambda_1(t) \\\\ \\lambda_2(t) \\\\ \\lambda_3(t) \\\\ \\lambda_4(t) \\end{bmatrix} ask price process N1(t)−N2(t)N_1(t) - N_2(t) bid price process N3(t)−N4(t)N_3(t) - N_4(t). mid price process p(t)=N1(t)+N3(t)−N2(t)−N4(t)p(t) = N_1(t) + N_3(t) - N_2(t) - N_4(t) plus initial mid price level. base intensity process μ=[μ1ζℓ(t−)ζℓ(t−)μ1],ℓ(t)=L(t)p(t)\\mu = \\begin{bmatrix} \\mu_1 \\\\ \\zeta \\ell(t-) \\\\ \\zeta \\ell(t-) \\\\ \\mu_1 \\end{bmatrix}, \\quad \\ell(t) = \\frac{L(t)}{p(t)} L(t)∈{0,1,2,⋯}L(t) \\\\{ 0, 1, 2, \\cdots \\} absolute level bid-ask spread L(t)=0L(t)=0 implying minimum level. details, see Modeling bid ask price dynamics extended Hawkes process empirical applications high-frequency stock market data. Note following code definition mu, n needed represent time tt Nc needed calculate level mid price. addition, kernel represented h(t,u)=[αs1αmαs20αw1αn1(u)αn1(u)αw2αw2αn2(u)αn2(u)αw10αs2αmαs1],h(t, u) =  \\begin{bmatrix} \\alpha_{s1} & \\alpha_{m} & \\alpha_{s2} & 0 \\\\   \\alpha_{w1} & \\alpha_{n1}(u) & \\alpha_{n1}(u) & \\alpha_{w2} \\\\  \\alpha_{w2} & \\alpha_{n2}(u) & \\alpha_{n2}(u) & \\alpha_{w1} \\\\  0 & \\alpha_{s2} & \\alpha_{m} & \\alpha_{s1} \\\\   \\end{bmatrix}, αn1(u)=−∑j=14λ2j(u)+ξℓ(u),αn2(u)=−∑j=14λ3j(u)+ξℓ(u), \\alpha_{n1}(u) = - \\sum_{j=1}^4 \\lambda_{2j}(u) + \\xi \\ell(u), \\quad \\alpha_{n2}(u) = - \\sum_{j=1}^4 \\lambda_{3j}(u) + \\xi \\ell(u), constant ξ≥0\\xi \\geq 0 λij\\lambda_{ij} component λi\\lambda_i λij(t)=∫−∞thij(t,u)dNj(u).\\lambda_{ij}(t) = \\int_{-\\infty}^t h_{ij}(t, u) d N_j(u). following code, separate constant part hh alpha stochastic part impact. represent λij\\lambda_{ij}, need lambda_component. Note separate log-likelihood estimation performed, parameter mark distribution estimated.","code":"# presumed initial bid and ask prices initial_ask_price <- 1250 #cents initial_bid_price <- 1150 #cents  initial_level <- round((initial_ask_price - initial_bid_price) - 1) initial_mid_price <- (initial_bid_price + initial_ask_price) / 2  mu <- function(param = c(mu1 = 0.08, zeta1 = 0.10), n=n, Nc=Nc, ...){    if(n == 1){          level <- initial_level     mid <- initial_mid_price        } else {          level <- Nc[n-1,1] - Nc[n-1,2] - (Nc[n-1,3] - Nc[n-1,4]) + initial_level     ask <- initial_ask_price + (Nc[n-1,1] - Nc[n-1,2])      bid <- initial_bid_price + (Nc[n-1,3] - Nc[n-1,4])      mid <- (ask + bid) / 2        }      if(level <= 0){     matrix(c(param[\"mu1\"], 0,              0, param[\"mu1\"]), nrow = 4)   } else {     matrix(c(param[\"mu1\"], param[\"zeta1\"] * level / mid,              param[\"zeta1\"]*level / mid, param[\"mu1\"]), nrow = 4)    }  } alpha <- function(param = c(alpha_s1=4, alpha_m=26, alpha_s2=5,                             alpha_w1=11, alpha_w2=7)){   matrix(c(param[\"alpha_s1\"], param[\"alpha_m\"], param[\"alpha_s2\"], 0,            param[\"alpha_w1\"], 0, 0, param[\"alpha_w2\"],            param[\"alpha_w2\"], 0, 0, param[\"alpha_w1\"],            0, param[\"alpha_s2\"], param[\"alpha_m\"], param[\"alpha_s1\"]), nrow = 4, byrow = TRUE) }  impact <- function(param = c(xi = 2.7), n=n, Nc=Nc, lambda_component = lambda_component, ... ){   if(n == 1){     level <-  initial_level     # mid <- initial_mid_price   } else {     level <- Nc[n,1] - Nc[n,2] - (Nc[n,3] - Nc[n,4]) + initial_level     ask <- initial_ask_price + (Nc[n,1] - Nc[n,2])     bid <- initial_bid_price + (Nc[n,3] - Nc[n,4])     mid <- (ask + bid)/2   }      lambda_component_matrix <- matrix(lambda_component[n, ], nrow=4, byrow=TRUE)    l2 <- sum(lambda_component_matrix[2,]) # sum of second row   l3 <- sum(lambda_component_matrix[3,]) # sum of third row    im <- matrix(c(0, 0, 0, 0,                  0, -l2 + param[\"xi\"]*level/mid, -l2 + param[\"xi\"]*level/mid, 0,                  0, -l3 + param[\"xi\"]*level/mid, -l3 + param[\"xi\"]*level/mid, 0,                  0, 0, 0, 0), nrow = 4, byrow = TRUE)  }  beta <- matrix(rep(50, 16), nrow = 4, byrow=TRUE)  rmark <- function(n=n, Nc=Nc, type, ...){   if(n == 1){     level <-  initial_level   } else {     level <- Nc[n-1,1] - Nc[n-1,2] - (Nc[n-1,3] - Nc[n-1,4]) + initial_level   }   if (type[n] == 2 | type[n] == 3){     min(level,  rgeom(1, p=0.65) + 1)   } else {     rgeom(1, p=0.65) + 1   } }   h_ba <- new(\"hspec\", mu = mu, alpha = alpha, beta = beta, impact=impact, rmark = rmark) h_ba #> An object of class \"hspec\" of 4-dimensional Hawkes process #>  #> Slot mu:  #> function (param = c(mu1 = 0.08, zeta1 = 0.1), n = n, Nc = Nc,  #>     ...)  #> { #>     if (n == 1) { #>         level <- initial_level #>         mid <- initial_mid_price #>     } #>     else { #>         level <- Nc[n - 1, 1] - Nc[n - 1, 2] - (Nc[n - 1, 3] -  #>             Nc[n - 1, 4]) + initial_level #>         ask <- initial_ask_price + (Nc[n - 1, 1] - Nc[n - 1,  #>             2]) #>         bid <- initial_bid_price + (Nc[n - 1, 3] - Nc[n - 1,  #>             4]) #>         mid <- (ask + bid)/2 #>     } #>     if (level <= 0) { #>         matrix(c(param[\"mu1\"], 0, 0, param[\"mu1\"]), nrow = 4) #>     } #>     else { #>         matrix(c(param[\"mu1\"], param[\"zeta1\"] * level/mid, param[\"zeta1\"] *  #>             level/mid, param[\"mu1\"]), nrow = 4) #>     } #> } #>  #> Slot alpha:  #> function (param = c(alpha_s1 = 4, alpha_m = 26, alpha_s2 = 5,  #>     alpha_w1 = 11, alpha_w2 = 7))  #> { #>     matrix(c(param[\"alpha_s1\"], param[\"alpha_m\"], param[\"alpha_s2\"],  #>         0, param[\"alpha_w1\"], 0, 0, param[\"alpha_w2\"], param[\"alpha_w2\"],  #>         0, 0, param[\"alpha_w1\"], 0, param[\"alpha_s2\"], param[\"alpha_m\"],  #>         param[\"alpha_s1\"]), nrow = 4, byrow = TRUE) #> } #> <bytecode: 0x000001ddec7c1850> #>  #> Slot beta:  #>      [,1] [,2] [,3] [,4] #> [1,]   50   50   50   50 #> [2,]   50   50   50   50 #> [3,]   50   50   50   50 #> [4,]   50   50   50   50 #>  #> Slot impact:  #> function (param = c(xi = 2.7), n = n, Nc = Nc, lambda_component = lambda_component,  #>     ...)  #> { #>     if (n == 1) { #>         level <- initial_level #>     } #>     else { #>         level <- Nc[n, 1] - Nc[n, 2] - (Nc[n, 3] - Nc[n, 4]) +  #>             initial_level #>         ask <- initial_ask_price + (Nc[n, 1] - Nc[n, 2]) #>         bid <- initial_bid_price + (Nc[n, 3] - Nc[n, 4]) #>         mid <- (ask + bid)/2 #>     } #>     lambda_component_matrix <- matrix(lambda_component[n, ],  #>         nrow = 4, byrow = TRUE) #>     l2 <- sum(lambda_component_matrix[2, ]) #>     l3 <- sum(lambda_component_matrix[3, ]) #>     im <- matrix(c(0, 0, 0, 0, 0, -l2 + param[\"xi\"] * level/mid,  #>         -l2 + param[\"xi\"] * level/mid, 0, 0, -l3 + param[\"xi\"] *  #>             level/mid, -l3 + param[\"xi\"] * level/mid, 0, 0, 0,  #>         0, 0), nrow = 4, byrow = TRUE) #> } #>  #> Slot rmark:  #> function (n = n, Nc = Nc, type, ...)  #> { #>     if (n == 1) { #>         level <- initial_level #>     } #>     else { #>         level <- Nc[n - 1, 1] - Nc[n - 1, 2] - (Nc[n - 1, 3] -  #>             Nc[n - 1, 4]) + initial_level #>     } #>     if (type[n] == 2 | type[n] == 3) { #>         min(level, rgeom(1, p = 0.65) + 1) #>     } #>     else { #>         rgeom(1, p = 0.65) + 1 #>     } #> } set.seed(1107) hr_ba <- hsim(h_ba, size=1000, lambda_component0 = matrix(rep(1, 16), 4)) summary(hr_ba) #> ------------------------------------------------------- #> Simulation result of exponential (marked) Hawkes model. #> Realized path : #>       arrival N1 N2 N3 N4 mark lambda1    lambda2   lambda3 lambda4 #>  [1,]  0.0000  0  0  0  0    0 4.08000  4.0082500 4.0082500  4.0800 #>  [2,]  3.6673  1  0  0  0    2 0.08000  0.0082500 0.0082500  0.0800 #>  [3,]  6.9225  2  0  0  0    1 0.08000  0.0084097 0.0084097  0.0800 #>  [4,] 20.0251  2  0  0  1    1 0.08000  0.0084894 0.0084894  0.0800 #>  [5,] 24.3957  2  0  0  2    3 0.08000  0.0085762 0.0085762  0.0800 #>  [6,] 24.4026  2  0  1  2    1 0.08000  4.9856950 7.8296138  2.9239 #>  [7,] 27.9067  3  0  1  2    1 0.08000  0.0087500 0.0087500  0.0800 #>  [8,] 27.9378  3  1  1  2    1 0.92442  2.3309869 1.4865661  0.0800 #>  [9,] 33.8868  3  1  2  2    2 0.08000  0.0087500 0.0087500  0.0800 #> [10,] 33.8900  3  1  2  3    1 4.33027  0.2054120 0.2054120 22.1814 #> [11,] 34.3764  4  1  2  3    1 0.08000  0.0086631 0.0086631  0.0800 #> [12,] 34.4342  4  2  2  3    1 0.30328  0.6227650 0.3994842  0.0800 #> [13,] 36.5641  5  2  2  3    2 0.08000  0.0086631 0.0086631  0.0800 #> [14,] 36.5658  5  3  2  3    2 3.74917 10.0990280 6.4298623  0.0800 #> [15,] 40.4590  5  3  2  4    1 0.08000  0.0086631 0.0086631  0.0800 #> [16,] 40.4666  5  3  3  4    1 0.08000  4.8059475 7.5472032  2.8213 #> [17,] 43.8835  6  3  3  4    5 0.08000  0.0086631 0.0086631  0.0800 #> [18,] 44.8818  7  3  3  4    2 0.08000  0.0090607 0.0090607  0.0800 #> [19,] 47.6976  7  3  3  5    2 0.08000  0.0092193 0.0092193  0.0800 #> [20,] 51.7138  8  3  3  5    1 0.08000  0.0093932 0.0093932  0.0800 #> ... with 980 more rows  #> ------------------------------------------------------- logLik(h_ba, inter_arrival = hr_ba$inter_arrival, type = hr_ba$type, Nc = hr_ba$Nc,        lambda_component0 = matrix(rep(1, 16), 4)) #> loglikelihood  #>     -1817.794 mle_ba <- hfit(h_ba, inter_arrival = hr_ba$inter_arrival, type = hr_ba$type,                lambda_component0 = matrix(rep(1, 16), 4)) summary(mle_ba) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 37 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -1810.43  #> 9  free parameters #> Estimates: #>           Estimate Std. error t value  Pr(> t)     #> mu1       0.069541   0.003612  19.254  < 2e-16 *** #> zeta1     0.135214   0.010751  12.577  < 2e-16 *** #> alpha_s1  4.656123   3.576523   1.302  0.19297     #> alpha_m  23.554234   9.212687   2.557  0.01057 *   #> alpha_s2  5.849629   6.196964   0.944  0.34519     #> alpha_w1 10.283680   3.279791   3.135  0.00172 **  #> alpha_w2  7.402709   1.284394   5.764 8.23e-09 *** #> beta1.1  51.868581   2.314850  22.407  < 2e-16 *** #> xi        2.376550   3.956622   0.601  0.54807     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> --------------------------------------------"},{"path":[]},{"path":"https://ksublee.github.io/emhawkes/articles/extended_example.html","id":"one-dimensional-model","dir":"Articles","previous_headings":"Point process with flexible residual","what":"One-dimensional model","title":"Extended example : emhawkes package","text":"code demonstrates create point process flexible residual structure. details, see Self mutually exciting point process embedding flexible residuals intensity discretely Markovian dynamics. distribution used example combination trapezoid exponential distribution. dresidual presidual functions receive necessary parameters bundled param vector. context Hawkes process model, functions correspond case residuals unit exponential distributions.  R code snippet demonstrates analyze residual process point process model using flexible distribution. logLik function used compute log-likelihood observed inter-arrival times (dh1_real$inter_arrival) based distribution specified hspec1_d. infer = TRUE parameter allows function also infer residual process, storing results infer_res_dh1.","code":"mu1_d <- 0.5; alpha1_d <- 1; beta1_d <- 1.2; a <- 0.7; ell <- 1.6 hspec1_d <- new(\"hspec\", mu=mu1_d, alpha=alpha1_d, beta=beta1_d,               rresidual = function(size) rtzexp(n=size, a = a, ell = ell),               dresidual = function(x, param = c(a = a, ell = ell))                 dtzexp(x, a = param[\"a\"], ell = param[\"ell\"]),               presidual = function(q, param = c(a = a, ell = ell))                   ptzexp(q, a = param[\"a\"], ell = param[\"ell\"]),               qresidual = function(p, param = c(a = a, ell = ell))                   qtzexp(p, a = param[\"a\"], ell = param[\"ell\"])) dh1_real <- hsim(hspec1_d, size = 3000) hist(   dh1_real$inter_arrival[dh1_real$inter_arrival < 3],   breaks = 50,   main = \"Histogram of Inter-Arrival Times\",   xlab = \"Inter-Arrival Time\",   ylab = \"Frequency\" ) # Infer the residual process using the log-likelihood method # 'infer_res_dh1' contains the inferred process data based on the inter-arrival times infer_res_dh1 <- logLik(hspec1_d, inter_arrival = dh1_real$inter_arrival, infer = TRUE)  # Plot a histogram of the inferred residual process hist(   infer_res_dh1$res_process1,   breaks = 100,   probability = TRUE,   main = \"Histogram of Inferred Residual Process\",   xlab = \"Residual Value\",   ylab = \"Density\" )  x <- seq(0, 8, 0.1)  lines(   x,   dtzexp(x, a = a, ell = ell),   col = 'red',   lwd = 2 )  # Add legend for clarity legend(\"topright\", legend = \"Theoretical PDF\", col = \"red\", lwd = 2)"},{"path":"https://ksublee.github.io/emhawkes/articles/extended_example.html","id":"two-dimenional-model","dir":"Articles","previous_headings":"Point process with flexible residual","what":"Two-dimenional model","title":"Extended example : emhawkes package","text":"method can extended multi-dimensions. basic approach extension similar multi-dimensional Hawkes models handled. Histogram inter-arrival times tzexp distribution.  Inference based flexible residual model. residual process follows residual distribution model.  eres_process follows exponential distribution.  maximum likelihood estimation. Uniform residual distribution example also provided. Histogram residual process:","code":"mu2_d <- matrix(c(0.3), nrow = 2) alpha2_d <- matrix(c(0.5, 0.8, 0.8, 0.5), nrow = 2, byrow = TRUE) beta2_d <- matrix(c(1.5, 1.5, 1.5, 1.5), nrow = 2, byrow = TRUE) a <- 0.7; ell <- 1.6  hspec2_du <- new(\"hspec\", mu=mu2_d, alpha=alpha2_d, beta=beta2_d,               rresidual = function(size) rtzexp(n=size, a = a, ell = ell),               dresidual = function(x, param = c(a = a, ell = ell))                 dtzexp(x, a = param[\"a\"], ell = param[\"ell\"]),               presidual = function(q, param = c(a = a, ell = ell))                   ptzexp(q, a = param[\"a\"], ell = param[\"ell\"]),               qresidual = function(p, param = c(a = a, ell = ell))                   qtzexp(p, a = param[\"a\"], ell = param[\"ell\"])) print(hspec2_du) #> An object of class \"hspec\" of 2-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,]  0.3 #> [2,]  0.3 #>  #> Slot alpha:  #>      [,1] [,2] #> [1,]  0.5  0.8 #> [2,]  0.8  0.5 #>  #> Slot beta:  #>      [,1] [,2] #> [1,]  1.5  1.5 #> [2,]  1.5  1.5 #>  #> Slot rresidual:  #> function (size)  #> rtzexp(n = size, a = a, ell = ell) #>  #> Slot dresidual:  #> function (x, param = c(a = a, ell = ell))  #> dtzexp(x, a = param[\"a\"], ell = param[\"ell\"]) #>  #> Slot presidual:  #> function (q, param = c(a = a, ell = ell))  #> ptzexp(q, a = param[\"a\"], ell = param[\"ell\"]) #>  #> Slot qresidual:  #> function (p, param = c(a = a, ell = ell))  #> qtzexp(p, a = param[\"a\"], ell = param[\"ell\"]) set.seed(1107) duh2_real <- hsim(hspec2_du, size = 10000) # Plot a histogram of the inter-arrival times less than 5 hist(   duh2_real$inter_arrival[duh2_real$inter_arrival < 5],   breaks = 50,   main = \"Histogram of Inter-Arrival Times\",   xlab = \"Inter-Arrival Time\",   ylab = \"Frequency\" ) infer_res_dh2 <- logLik(hspec2_du,                          inter_arrival = duh2_real$inter_arrival,                          type = duh2_real$type, infer = TRUE) # Plot a histogram of the inferred residual process hist(   infer_res_dh2$res_process2,   breaks = 50,   probability = TRUE,   main = \"Histogram of Inferred Residual Process\",   xlab = \"Residual Value\",   ylab = \"Density\" )  # Generate a sequence of x values for plotting the theoretical distribution x <- seq(0, 8, 0.1)  # Add a line to the histogram representing the theoretical density function lines(   x,   dtzexp(x, a = a, ell = ell),   col = 'red',   lwd = 2 )  # Add legend for clarity legend(\"topright\", legend = \"Theoretical PDF\", col = \"red\", lwd = 2) hist(   infer_res_dh2$eres_process1,   breaks = 50,   probability = TRUE,   main = \"Histogram of Inferred eResidual Process\",   xlab = \"Residual Value\",   ylab = \"Density\" )  # Generate a sequence of x values for plotting the theoretical distribution x <- seq(0, 8, 0.1)  # Add a line to the histogram representing the theoretical density function lines(   x,   dexp(x),   col = 'red',   lwd = 2 )  # Add legend for clarity legend(\"topright\", legend = \"Theoretical PDF\", col = \"red\", lwd = 2) mle_dh <- hfit(hspec2_du,                 inter_arrival = duh2_real$inter_arrival,                 type = duh2_real$type,                constraint=list(ineqA=rbind(diag(6)), ineqB=matrix(rep(0,6), nrow=6))) summary(mle_dh) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 65 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -12548.98  #> 6  free parameters #> Estimates: #>          Estimate Std. error t value Pr(> t)     #> mu1       0.28959        NaN     NaN     NaN     #> alpha1.1  0.49525        NaN     NaN     NaN     #> alpha1.2  0.81380    0.02412   33.74  <2e-16 *** #> beta1.1   1.50551    0.02784   54.07  <2e-16 *** #> a         0.69286        NaN     NaN     NaN     #> ell       1.58421        NaN     NaN     NaN     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Warning: constrained likelihood estimation. Inference is probably wrong #> Constrained optimization based on constrOptim  #> 1  outer iterations, barrier value -0.00051762  #> -------------------------------------------- #set.seed(117) mu2_d <- matrix(c(0.5), nrow = 2) alpha2_d <- matrix(c(0.3, 0.3, 0.3, 0.3), nrow = 2, byrow = TRUE) beta2_d <- matrix(c(1.2, 1.2, 1.2, 1.2), nrow = 2, byrow = TRUE)  hspec2_du <- new(\"hspec\", mu=mu2_d, alpha=alpha2_d, beta=beta2_d,                  rresidual = function(size) runif(n=size, 0, 2),                  dresidual = function(x, param = c()) dunif(x, 0, 2),                  presidual = function(q, param = c()) punif(q, 0, 2),                  qresidual = function(p, param = c()) qunif(p, 0, 2))  duh2_real <- hsim(hspec2_du, size = 5000) infer_res_duh2 <- logLik(hspec2_du,                           inter_arrival = duh2_real$inter_arrival,                           type = duh2_real$type, infer = TRUE)  hist(   infer_res_duh2$res_process1,   breaks = 50,   probability = TRUE,   main = \"Histogram of Inferred Residual Process\",   xlab = \"Residual Value\",   ylab = \"Density\" )"},{"path":"https://ksublee.github.io/emhawkes/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kyungsub Lee. Author, maintainer.","code":""},{"path":"https://ksublee.github.io/emhawkes/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lee K (2025). emhawkes: Exponential Multivariate Hawkes Model. R package version 0.9.8, https://github.com/ksublee/emhawkes.","code":"@Manual{,   title = {emhawkes: Exponential Multivariate Hawkes Model},   author = {Kyungsub Lee},   year = {2025},   note = {R package version 0.9.8},   url = {https://github.com/ksublee/emhawkes}, }"},{"path":"https://ksublee.github.io/emhawkes/index.html","id":"emhawkes","dir":"","previous_headings":"","what":"Exponential Multivariate Hawkes Model","title":"Exponential Multivariate Hawkes Model","text":"detailed extended example, see extended vignettes.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/expected_tau.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected Inter-Arrival Time — expected_tau","title":"Expected Inter-Arrival Time — expected_tau","text":"Computes conditional expected time next event.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/expected_tau.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected Inter-Arrival Time — expected_tau","text":"","code":"expected_tau(   object,   rambda_component,   type = 1,   mu = NULL,   beta = NULL,   tol = .Machine$double.eps^0.25,   max_upper = Inf,   subdivisions = 400L )"},{"path":"https://ksublee.github.io/emhawkes/reference/expected_tau.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected Inter-Arrival Time — expected_tau","text":"object object class hspec. rambda_component Rambda component. type Process dimension index (default 1). mu Optional mu value (overrides object@mu provided). beta Optional beta value (overrides object@beta provided). tol Relative tolerance numerical integration. max_upper Upper integration limit. subdivisions Number subdivisions numerical integration.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/expected_tau.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected Inter-Arrival Time — expected_tau","text":"Expected value next inter-arrival time.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/hfit.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform Maximum Likelihood Estimation — hfit","title":"Perform Maximum Likelihood Estimation — hfit","text":"generic function named hfit designed estimating parameters exponential Hawkes model. implemented S4 method two main reasons:","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/hfit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform Maximum Likelihood Estimation — hfit","text":"","code":"hfit(   object,   inter_arrival = NULL,   type = NULL,   mark = NULL,   N = NULL,   Nc = NULL,   lambda_component0 = NULL,   N0 = NULL,   mylogLik = NULL,   reduced = TRUE,   grad = NULL,   hess = NULL,   constraint = NULL,   method = \"BFGS\",   verbose = FALSE,   ... )  # S4 method for class 'hspec' hfit(   object,   inter_arrival = NULL,   type = NULL,   mark = NULL,   N = NULL,   Nc = NULL,   lambda_component0 = NULL,   N0 = NULL,   mylogLik = NULL,   reduced = TRUE,   grad = NULL,   hess = NULL,   constraint = NULL,   method = \"BFGS\",   verbose = FALSE,   ... )"},{"path":"https://ksublee.github.io/emhawkes/reference/hfit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform Maximum Likelihood Estimation — hfit","text":"object hspec-class object containing parameter values. inter_arrival vector inter-arrival times events across dimensions, starting zero. type vector indicating dimensions, represented numbers like 1, 2, 3, etc., starting zero. mark vector mark (jump) sizes, starting zero. N matrix representing counting processes. Nc matrix counting processes weighted mark sizes. lambda_component0 Initial values lambda component \\(\\lambda_{ij}\\). Can numeric value matrix. Must number rows columns alpha beta object. N0 Initial values counting processes matrix N. mylogLik user-defined log-likelihood function, must accept object argument consistent object. reduced Logical; TRUE, performs reduced estimation. grad gradient matrix likelihood function. Refer maxLik details. hess Hessian matrix likelihood function. Refer maxLik details. constraint Constraint matrices. Refer maxLik details. method optimization method used. Refer maxLik details. verbose Logical; TRUE, prints progress estimation process. ... Additional parameters optimization. Refer maxLik details.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/hfit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform Maximum Likelihood Estimation — hfit","text":"maxLik object","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/hfit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform Maximum Likelihood Estimation — hfit","text":"Model Representation: represent structure model hspec object. multivariate marked Hawkes model numerous variations, using S4 class allows flexible structured approach. Optimization Initialization: provide starting point numerical optimization. parameter values assigned hspec slots serve initial values optimization process. function utilizes maxLik package optimization.","code":""},{"path":[]},{"path":"https://ksublee.github.io/emhawkes/reference/hfit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform Maximum Likelihood Estimation — hfit","text":"","code":"# example 1 mu <- c(0.1, 0.1) alpha <- matrix(c(0.2, 0.1, 0.1, 0.2), nrow=2, byrow=TRUE) beta <- matrix(c(0.9, 0.9, 0.9, 0.9), nrow=2, byrow=TRUE) h <- new(\"hspec\", mu=mu, alpha=alpha, beta=beta) res <- hsim(h, size=100) summary(hfit(h, inter_arrival=res$inter_arrival, type=res$type)) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 29 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -245.0405  #> 4  free parameters #> Estimates: #>          Estimate Std. error t value  Pr(> t)     #> mu1       0.10357    0.01916   5.407 6.41e-08 *** #> alpha1.1  0.21600    0.09772   2.210 0.027081 *   #> alpha1.2  0.29650    0.11645   2.546 0.010891 *   #> beta1.1   1.11245    0.33450   3.326 0.000882 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> --------------------------------------------   # example 2 # \\donttest{ mu <- matrix(c(0.08, 0.08, 0.05, 0.05), nrow = 4) alpha <- function(param = c(alpha11 = 0, alpha12 = 0.4, alpha33 = 0.5, alpha34 = 0.3)){   matrix(c(param[\"alpha11\"], param[\"alpha12\"], 0, 0,            param[\"alpha12\"], param[\"alpha11\"], 0, 0,            0, 0, param[\"alpha33\"], param[\"alpha34\"],            0, 0, param[\"alpha34\"], param[\"alpha33\"]), nrow = 4, byrow = TRUE) } beta <- matrix(c(rep(0.6, 8), rep(1.2, 8)), nrow = 4, byrow = TRUE)  impact <- function(param = c(alpha1n=0, alpha1w=0.2, alpha2n=0.001, alpha2w=0.1),                    n=n, N=N, ...){    Psi <- matrix(c(0, 0, param['alpha1w'], param['alpha1n'],                   0, 0, param['alpha1n'], param['alpha1w'],                   param['alpha2w'], param['alpha2n'], 0, 0,                   param['alpha2n'], param['alpha2w'], 0, 0), nrow=4, byrow=TRUE)    ind <- N[,\"N1\"][n] - N[,\"N2\"][n] > N[,\"N3\"][n] - N[,\"N4\"][n] + 0.5    km <- matrix(c(!ind, !ind, !ind, !ind,                  ind, ind, ind, ind,                  ind, ind, ind, ind,                  !ind, !ind, !ind, !ind), nrow = 4, byrow = TRUE)    km * Psi } h <- new(\"hspec\",          mu = mu, alpha = alpha, beta = beta, impact = impact) hr <- hsim(h, size=100) plot(hr$arrival, hr$N[,'N1'] - hr$N[,'N2'], type='s') lines(hr$N[,'N3'] - hr$N[,'N4'], type='s', col='red')  fit <- hfit(h, hr$inter_arrival, hr$type) summary(fit) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 145 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -158.4592  #> 12  free parameters #> Estimates: #>         Estimate Std. error t value  Pr(> t)     #> mu1      0.69235    0.42350   1.635   0.1021     #> mu3      0.07379    0.03507   2.104   0.0354 *   #> alpha11 -0.12631    0.06532  -1.934   0.0532 .   #> alpha12  0.01428    0.04905   0.291   0.7709     #> alpha33  0.96110    0.21447   4.481 7.42e-06 *** #> alpha34  0.29568    0.11629   2.543   0.0110 *   #> beta1.1  0.10271    0.08793   1.168   0.2428     #> beta3.1  1.33411    0.22804   5.850 4.91e-09 *** #> alpha1n  0.03457    0.06731   0.514   0.6076     #> alpha1w  0.04974    0.06823   0.729   0.4660     #> alpha2n -2.47298    0.27550  -8.976  < 2e-16 *** #> alpha2w  1.00872    0.11328   8.905  < 2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> -------------------------------------------- # }  # example 3 # \\donttest{ mu <- c(0.15, 0.15) alpha <- matrix(c(0.75, 0.6, 0.6, 0.75), nrow=2, byrow=TRUE) beta <- matrix(c(2.6, 2.6, 2.6, 2.6), nrow=2, byrow=TRUE) rmark <- function(param = c(p=0.65), ...){   rgeom(1, p=param[1]) + 1 } impact <- function(param = c(eta1=0.2), alpha, n, mark, ...){   ma <- matrix(rep(mark[n]-1, 4), nrow = 2)   alpha * ma * matrix( rep(param[\"eta1\"], 4), nrow=2) } h1 <- new(\"hspec\", mu=mu, alpha=alpha, beta=beta,           rmark = rmark,           impact=impact) res <- hsim(h1, size=100, lambda_component0 = matrix(rep(0.1,4), nrow=2))  fit <- hfit(h1,             inter_arrival = res$inter_arrival,             type = res$type,             mark = res$mark,             lambda_component0 = matrix(rep(0.1,4), nrow=2)) summary(fit) #> -------------------------------------------- #> Maximum Likelihood estimation #> BFGS maximization, 37 iterations #> Return code 0: successful convergence  #> Log-Likelihood: -191.1433  #> 5  free parameters #> Estimates: #>          Estimate Std. error t value  Pr(> t)     #> mu1       0.10755    0.02344   4.588 4.47e-06 *** #> alpha1.1  0.62799    0.25208   2.491  0.01273 *   #> alpha1.2  0.55832    0.22125   2.523  0.01162 *   #> beta1.1   2.11657    0.73502   2.880  0.00398 **  #> eta1      0.10179    0.27611   0.369  0.71237     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #> -------------------------------------------- # } # For more information, please see vignettes."},{"path":"https://ksublee.github.io/emhawkes/reference/hreal.html","id":null,"dir":"Reference","previous_headings":"","what":"Realization of Hawkes Process — hreal","title":"Realization of Hawkes Process — hreal","text":"hreal list containing following components: hspec: S4 object class hspec-class specifies parameter values. inter_arrival: time intervals consecutive events. arrival: cumulative sum inter_arrival times. type: integer representing type event. mark: size mark, providing additional information associated event. N: counting process tracks number events. Nc: counting process tracks number events, weighted mark. lambda: left-continuous intensity process. lambda_component: component intensity process, \\(\\lambda_{ij}\\), excludes mu. rambda: right-continuous intensity process. rambda_component: right-continuous version lambda_component. Functions printing hreal objects provided.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/hreal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Realization of Hawkes Process — hreal","text":"","code":"# S3 method for class 'hreal' print(x, n = 20, ...)  # S3 method for class 'hreal' summary(object, n = 20, ...)  # S3 method for class 'hreal' as.matrix(x, ...)"},{"path":"https://ksublee.github.io/emhawkes/reference/hreal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Realization of Hawkes Process — hreal","text":"x S3 object class hreal. n number rows display. ... Additional arguments passed methods. object S3 object class hreal.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/hsim.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate multivariate Hawkes process with exponential kernel. — hsim","title":"Simulate multivariate Hawkes process with exponential kernel. — hsim","text":"method simulate multivariate Hawkes processes. object hspec-class contains parameter values mu, alpha, beta. mark (jump) structure may may included. returns object class hreal contains inter_arrival, arrival, type, mark, N, Nc, lambda, lambda_component, rambda, rambda_component.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/hsim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate multivariate Hawkes process with exponential kernel. — hsim","text":"","code":"hsim(   object,   size = 100,   lambda_component0 = NULL,   N0 = NULL,   Nc0 = NULL,   verbose = FALSE,   ... )  # S4 method for class 'hspec' hsim(   object,   size = 100,   lambda_component0 = NULL,   N0 = NULL,   Nc0 = NULL,   verbose = FALSE,   ... )"},{"path":"https://ksublee.github.io/emhawkes/reference/hsim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate multivariate Hawkes process with exponential kernel. — hsim","text":"object hspec-class. S4 object specifies parameter values. size Number observations. lambda_component0 Initial values lambda component \\(\\lambda_{ij}\\). Can numeric value matrix. Must number rows columns alpha beta object. N0 Starting values N default value 0. Nc0 Starting values Nc default value 0. verbose Logical. TRUE, print progress messages simulation. Default FALSE. ... arguments passed methods.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/hsim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate multivariate Hawkes process with exponential kernel. — hsim","text":"hreal S3-object, summary Hawkes process realization.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/hsim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate multivariate Hawkes process with exponential kernel. — hsim","text":"","code":"# example 1  mu <- 1; alpha <- 1; beta <- 2 h <- new(\"hspec\", mu=mu, alpha=alpha, beta=beta) hsim(h, size=100) #> ------------------------------------------------------- #> Simulation result of exponential (marked) Hawkes model. #> An object of class \"hspec\" of 1-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,]    1 #>  #> Slot alpha:  #>      [,1] #> [1,]    1 #>  #> Slot beta:  #>      [,1] #> [1,]    2 #>  #> Realized path : #>       arrival N1 mark lambda1 lambda11 #>  [1,]  0.0000  0    0   1.500   0.5000 #>  [2,]  0.6689  1    1   1.131   0.1312 #>  [3,]  1.3586  2    1   1.285   0.2848 #>  [4,]  1.4812  3    1   2.005   1.0054 #>  [5,]  1.4846  4    1   2.992   1.9920 #>  [6,]  1.5126  5    1   3.829   2.8290 #>  [7,]  1.9171  6    1   2.705   1.7049 #>  [8,]  2.0790  7    1   2.957   1.9567 #>  [9,]  3.3016  8    1   1.256   0.2564 #> [10,]  3.3701  9    1   2.095   1.0954 #> [11,]  4.1209 10    1   1.467   0.4669 #> [12,]  4.2309 11    1   2.177   1.1771 #> [13,]  4.2464 12    1   3.111   2.1107 #> [14,]  4.6010 13    1   2.531   1.5307 #> [15,]  4.8651 14    1   2.492   1.4923 #> [16,]  4.9816 15    1   2.974   1.9743 #> [17,]  5.0106 16    1   3.807   2.8067 #> [18,]  5.3251 17    1   3.029   2.0295 #> [19,]  5.3578 18    1   3.837   2.8372 #> [20,]  5.9318 19    1   2.217   1.2174 #> ... with 80 more rows  #> -------------------------------------------------------   # example 2 mu <- matrix(c(0.1, 0.1), nrow=2) alpha <- matrix(c(0.2, 0.1, 0.1, 0.2), nrow=2, byrow=TRUE) beta <- matrix(c(0.9, 0.9, 0.9, 0.9), nrow=2, byrow=TRUE) h <- new(\"hspec\", mu=mu, alpha=alpha, beta=beta) res <- hsim(h, size=100) print(res) #> ------------------------------------------------------- #> Simulation result of exponential (marked) Hawkes model. #> An object of class \"hspec\" of 2-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,]  0.1 #> [2,]  0.1 #>  #> Slot alpha:  #>      [,1] [,2] #> [1,]  0.2  0.1 #> [2,]  0.1  0.2 #>  #> Slot beta:  #>      [,1] [,2] #> [1,]  0.9  0.9 #> [2,]  0.9  0.9 #>  #> Realized path : #>       arrival N1 N2 mark lambda1 lambda2  lambda11  lambda12  lambda21 #>  [1,]   0.000  0  0    0  0.1500  0.1500 3.333e-02 1.667e-02 1.667e-02 #>  [2,]   2.637  1  0    1  0.1047  0.1047 3.107e-03 1.553e-03 1.553e-03 #>  [3,]  17.416  2  0    1  0.1000  0.1000 3.397e-07 2.598e-09 1.698e-07 #>  [4,]  28.979  2  1    1  0.1000  0.1000 6.044e-06 7.851e-14 3.022e-06 #>  [5,]  31.051  2  2    1  0.1155  0.1310 9.367e-07 1.550e-02 4.684e-07 #>  [6,]  34.295  2  3    1  0.1062  0.1125 5.052e-08 6.229e-03 2.526e-08 #>  [7,]  37.816  3  3    1  0.1045  0.1089 2.126e-09 4.469e-03 1.063e-09 #>  [8,]  39.752  3  4    1  0.1358  0.1191 3.501e-02 7.825e-04 1.751e-02 #>  [9,]  40.742  3  5    1  0.1557  0.1899 1.436e-02 4.134e-02 7.181e-03 #> [10,]  40.811  4  5    1  0.2464  0.3725 1.350e-02 1.329e-01 6.751e-03 #> [11,]  51.164  4  6    1  0.1000  0.1000 1.918e-05 1.193e-05 9.589e-06 #> [12,]  53.009  4  7    1  0.1190  0.1380 3.642e-06 1.899e-02 1.821e-06 #> [13,]  53.134  4  8    1  0.2064  0.3127 3.255e-06 1.064e-01 1.628e-06 #> [14,]  56.288  4  9    1  0.1121  0.1241 1.904e-07 1.207e-02 9.521e-08 #> [15,]  63.628  5  9    1  0.1002  0.1003 2.575e-10 1.516e-04 1.288e-10 #> [16,]  66.953  5 10    1  0.1100  0.1050 1.003e-02 7.605e-06 5.017e-03 #> [17,]  68.188  5 11    1  0.1362  0.1675 3.301e-03 3.290e-02 1.651e-03 #> [18,]  68.941  5 12    1  0.1692  0.2359 1.677e-03 6.752e-02 8.386e-04 #> [19,]  68.968  5 13    1  0.2651  0.4278 1.637e-03 1.635e-01 8.184e-04 #> [20,]  69.698  5 14    1  0.2373  0.3734 8.480e-04 1.365e-01 4.240e-04 #>        lambda22 #>  [1,] 3.333e-02 #>  [2,] 3.107e-03 #>  [3,] 5.196e-09 #>  [4,] 1.570e-13 #>  [5,] 3.099e-02 #>  [6,] 1.246e-02 #>  [7,] 8.939e-03 #>  [8,] 1.565e-03 #>  [9,] 8.268e-02 #> [10,] 2.657e-01 #> [11,] 2.387e-05 #> [12,] 3.799e-02 #> [13,] 2.127e-01 #> [14,] 2.414e-02 #> [15,] 3.031e-04 #> [16,] 1.521e-05 #> [17,] 6.580e-02 #> [18,] 1.350e-01 #> [19,] 3.270e-01 #> [20,] 2.730e-01 #> ... with 80 more rows  #> -------------------------------------------------------"},{"path":"https://ksublee.github.io/emhawkes/reference/hspec-class.html","id":null,"dir":"Reference","previous_headings":"","what":"An S4 Class Representing an Exponential Marked Hawkes Model — hspec-class","title":"An S4 Class Representing an Exponential Marked Hawkes Model — hspec-class","text":"class defines marked Hawkes model exponential kernel. intensity ground process expressed : $$\\lambda(t) = \\mu + \\int_{(-\\infty,t)\\times E} ( \\alpha + g(u, z) )  e^{-\\beta (t-u)} M(du \\times dz).$$ details, refer vignettes.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/hspec-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"An S4 Class Representing an Exponential Marked Hawkes Model — hspec-class","text":"\\(\\mu\\) base intensity, typically constant vector function. \\(\\alpha\\) constant matrix representing impact intensities events, stored alpha slot. \\(\\beta\\) constant matrix exponential decay rates, stored beta slot. \\(z\\) represents mark can generated rmark slot. \\(g\\) represented eta linear function \\(z\\), impact genenral function. mu, alpha beta required slots every exponential Hawkes model. rmark impact additional slots.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/hspec-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"An S4 Class Representing an Exponential Marked Hawkes Model — hspec-class","text":"mu numeric value, matrix, function. numeric, automatically converted matrix. alpha numeric value, matrix, function. numeric, automatically converted matrix, representing exciting term. beta numeric value, matrix, function. numeric, automatically converted matrix, representing exponential decay. eta numeric value, matrix, function. numeric, automatically converted matrix, representing impact additional mark. impact function describing -effects mark \\(\\lambda\\), first argument always param. dimens dimension model. rmark function generates marks counting process, used simulations. dmark density function mark, used estimation. type_col_map mapping type column number kernel used multi-kernel models. rresidual function generating residuals, analogous R random number generator function, specifically discrete Hawkes model. dresidual density function residual. presidual distribution function residual. qresidual quantile function residual.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/hspec-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"An S4 Class Representing an Exponential Marked Hawkes Model — hspec-class","text":"","code":"MU <- matrix(c(0.2), nrow = 2) ALPHA <- matrix(c(0.75, 0.92, 0.92, 0.75), nrow = 2, byrow=TRUE) BETA <- matrix(c(2.25, 2.25, 2.25, 2.25), nrow = 2, byrow=TRUE) mhspec2 <- new(\"hspec\", mu=MU, alpha=ALPHA, beta=BETA) mhspec2 #> An object of class \"hspec\" of 2-dimensional Hawkes process #>  #> Slot mu:  #>      [,1] #> [1,]  0.2 #> [2,]  0.2 #>  #> Slot alpha:  #>      [,1] [,2] #> [1,] 0.75 0.92 #> [2,] 0.92 0.75 #>  #> Slot beta:  #>      [,1] [,2] #> [1,] 2.25 2.25 #> [2,] 2.25 2.25 #>"},{"path":"https://ksublee.github.io/emhawkes/reference/hvol.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Hawkes volatility — hvol","title":"Compute Hawkes volatility — hvol","text":"function computes Hawkes volatility. works bi-variate Hawkes process.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/hvol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Hawkes volatility — hvol","text":"","code":"hvol(   object,   horizon = 1,   inter_arrival = NULL,   type = NULL,   mark = NULL,   dependence = FALSE,   lambda_component0 = NULL,   ... )  # S4 method for class 'hspec' hvol(   object,   horizon = 1,   inter_arrival = NULL,   type = NULL,   mark = NULL,   dependence = FALSE,   lambda_component0 = NULL,   ... )"},{"path":"https://ksublee.github.io/emhawkes/reference/hvol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Hawkes volatility — hvol","text":"object hspec-class horizon Time horizon volatility. inter_arrival Inter-arrival times events includes inter-arrival events occur dimensions. Start zero. type vector dimensions. Distinguished numbers, 1, 2, 3, . Start zero. mark vector mark (jump) sizes. Start zero. dependence Dependence mark previous sigma-algebra. lambda_component0 matrix starting values lambda component. ... arguments passed methods.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/infer_lambda.html","id":null,"dir":"Reference","previous_headings":"","what":"Infer lambda process with given Hawkes model and realized path — infer_lambda","title":"Infer lambda process with given Hawkes model and realized path — infer_lambda","text":"method compute inferred lambda process returns hreal form. realized path Hawkes process parameter value, can compute inferred lambda processes. Similarly method hfit, input arguments inter_arrival, type, mark, equivalently, N Nc.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/infer_lambda.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infer lambda process with given Hawkes model and realized path — infer_lambda","text":"","code":"infer_lambda(   object,   inter_arrival = NULL,   type = NULL,   mark = NULL,   N = NULL,   Nc = NULL,   lambda_component0 = NULL,   N0 = NULL,   Nc0 = NULL,   ... )  # S4 method for class 'hspec' infer_lambda(   object,   inter_arrival = NULL,   type = NULL,   mark = NULL,   N = NULL,   Nc = NULL,   lambda_component0 = NULL,   N0 = NULL,   Nc0 = NULL,   ... )"},{"path":"https://ksublee.github.io/emhawkes/reference/infer_lambda.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infer lambda process with given Hawkes model and realized path — infer_lambda","text":"object hspec-class. object includes parameter values. inter_arrival inter-arrival times events. includes inter-arrival events occur dimensions. Start zero. type vector dimensions. Distinguished numbers, 1, 2, 3, . Start zero. mark vector mark (jump) sizes. Start zero. N Hawkes process. provided, generate using inter_arrival type. Nc mark accumulated Hawkes process. provided, generate using inter_arrival, type mark. lambda_component0 Initial values lambda component \\(\\lambda_{ij}\\). Can numeric value matrix. Must number rows columns alpha beta object. N0 initial values N. Nc0 initial values Nc. ... arguments passed methods.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/infer_lambda.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Infer lambda process with given Hawkes model and realized path — infer_lambda","text":"hreal S3-object, inferred intensity.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/infer_lambda.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Infer lambda process with given Hawkes model and realized path — infer_lambda","text":"","code":"mu <- c(0.1, 0.1) alpha <- matrix(c(0.2, 0.1, 0.1, 0.2), nrow=2, byrow=TRUE) beta <- matrix(c(0.9, 0.9, 0.9, 0.9), nrow=2, byrow=TRUE) h <- new(\"hspec\", mu=mu, alpha=alpha, beta=beta) res <- hsim(h, size=100) summary(res) #> ------------------------------------------------------- #> Simulation result of exponential (marked) Hawkes model. #> Realized path : #>       arrival N1 N2 mark lambda1 lambda2 #>  [1,]  0.0000  0  0    0 0.15000 0.15000 #>  [2,]  4.5840  1  0    1 0.10081 0.10081 #>  [3,]  5.9065  1  1    1 0.16107 0.13066 #>  [4,]  7.6876  2  1    1 0.13242 0.14643 #>  [5,]  7.9299  2  2    1 0.28688 0.21774 #>  [6,] 17.5999  3  2    1 0.10005 0.10005 #>  [7,] 21.6491  4  2    1 0.10523 0.10262 #>  [8,] 21.9249  5  2    1 0.26012 0.18006 #>  [9,] 30.9103  6  2    1 0.10011 0.10006 #> [10,] 33.2391  6  3    1 0.12461 0.11230 #> [11,] 33.5206  7  3    1 0.19671 0.26478 #> [12,] 33.6337  8  3    1 0.36801 0.33917 #> [13,] 33.6810  9  3    1 0.54848 0.42502 #> [14,] 33.8535 10  3    1 0.65523 0.46389 #> [15,] 34.0128 11  3    1 0.75440 0.50196 #> [16,] 34.1304 11  4    1 0.86854 0.55152 #> [17,] 35.1472 12  4    1 0.44785 0.36093 #> [18,] 35.5445 12  5    1 0.48312 0.35241 #> [19,] 35.7998 12  6    1 0.48395 0.45954 #> [20,] 39.4787 13  6    1 0.11765 0.12041 #> ... with 80 more rows  #> ------------------------------------------------------- res2 <- infer_lambda(h, res$inter_arrival, res$type) #> Warning: The 'infer_lambda' function is deprecated. Please use 'logLik' with 'infer = TRUE' instead. #> The initial values for intensity processes are not provided. Internally determined initial values are used. summary(res2) #>                  Length Class  Mode    #> loglikelihood      1    -none- numeric #> lambda           200    -none- numeric #> lambda_component 400    -none- numeric #> rambda           200    -none- numeric #> rambda_component 400    -none- numeric #> res_process1      42    -none- numeric #> res_process2      55    -none- numeric"},{"path":"https://ksublee.github.io/emhawkes/reference/logLik.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the Log-Likelihood Function — logLik,hspec-method","title":"Compute the Log-Likelihood Function — logLik,hspec-method","text":"Calculates log-likelihood Hawkes model.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/logLik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the Log-Likelihood Function — logLik,hspec-method","text":"","code":"# S4 method for class 'hspec' logLik(   object,   inter_arrival,   type = NULL,   mark = NULL,   N = NULL,   Nc = NULL,   N0 = NULL,   Nc0 = NULL,   lambda_component0 = NULL,   infer = FALSE,   ... )"},{"path":"https://ksublee.github.io/emhawkes/reference/logLik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the Log-Likelihood Function — logLik,hspec-method","text":"object hspec-class object containing parameter values computing log-likelihood. inter_arrival vector inter-arrival times events across dimensions, starting zero. type vector indicating dimensions, represented numbers (1, 2, 3, etc.), starting zero. mark vector mark (jump) sizes, starting zero. N matrix representing counting processes. Nc matrix counting processes weighted mark sizes. N0 matrix initial values N. Nc0 matrix initial values Nc. lambda_component0 Initial values lambda component \\(\\lambda_{ij}\\). Can numeric value matrix. Must number rows columns alpha beta object. infer Logical ... Additional arguments passed methods.","code":""},{"path":[]},{"path":"https://ksublee.github.io/emhawkes/reference/residual_process.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute residual process — residual_process","title":"Compute residual process — residual_process","text":"Using random time change, function compute residual process, inter-arrival time standard Poisson process. Therefore, return values follow exponential distribution rate 1, model rambda correctly specified.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/residual_process.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute residual process — residual_process","text":"","code":"residual_process(   component,   inter_arrival,   type,   rambda_component,   mu,   beta,   dimens = NULL,   mark = NULL,   N = NULL,   Nc = NULL,   lambda_component0 = NULL,   N0 = NULL,   ... )"},{"path":"https://ksublee.github.io/emhawkes/reference/residual_process.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute residual process — residual_process","text":"component component type get residual process. inter_arrival Inter-arrival times events. includes inter-arrival events occur dimensions. Start zero. type vector types distinguished numbers, 1, 2, 3, . Start zero. rambda_component Right continuous version lambda process. mu Numeric value matrix function. numeric, automatically converted matrix. beta Numeric value matrix function. numeric, automatically converted matrix, exponential decay. dimens Dimension model. omitted, set length mu. mark vector realized mark (jump) sizes. Start zero. N matrix counting processes. Nc matrix counting processes weighted mark. lambda_component0 initial values lambda component. Must dimensional matrix hspec. N0 initial value N ... arguments passed methods.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/residual_process.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute residual process — residual_process","text":"","code":"mu <- c(0.1, 0.1) alpha <- matrix(c(0.2, 0.1, 0.1, 0.2), nrow=2, byrow=TRUE) beta <- matrix(c(0.9, 0.9, 0.9, 0.9), nrow=2, byrow=TRUE) h <- new(\"hspec\", mu=mu, alpha=alpha, beta=beta) res <- hsim(h, size=1000) rp <- residual_process(component = 1, res$inter_arrival, res$type, res$rambda_component, mu, beta) #> Warning: The 'residual_process' function is deprecated. Please use 'logLik' with 'infer = TRUE' instead."},{"path":"https://ksublee.github.io/emhawkes/reference/set_residual.html","id":null,"dir":"Reference","previous_headings":"","what":"Set Residual Distribution Functions for Hawkes Model Specification — set_residual","title":"Set Residual Distribution Functions for Hawkes Model Specification — set_residual","text":"Sets residual distribution functions (density, CDF, quantile, random generation) Hawkes model specification object fixed parameters.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/set_residual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set Residual Distribution Functions for Hawkes Model Specification — set_residual","text":"","code":"set_residual(   object,   param,   dresidual = NULL,   presidual = NULL,   qresidual = NULL,   rresidual = NULL,   ... )  # S4 method for class 'hspec' set_residual(   object,   param,   dresidual = NULL,   presidual = NULL,   qresidual = NULL,   rresidual = NULL )"},{"path":"https://ksublee.github.io/emhawkes/reference/set_residual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set Residual Distribution Functions for Hawkes Model Specification — set_residual","text":"object object class hspec (Hawkes model specification) param named numeric vector parameters residual distribution dresidual Density function residual distribution (optional) presidual Cumulative distribution function (CDF) residual distribution (optional) qresidual Quantile function residual distribution (optional) rresidual Random generation function residual distribution (optional) ... Additional arguments future extensions","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/set_residual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set Residual Distribution Functions for Hawkes Model Specification — set_residual","text":"updated hspec object residual functions set","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/set_residual.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set Residual Distribution Functions for Hawkes Model Specification — set_residual","text":"method allows setting residual distribution functions flexible model. param argument functions defaults parameters provided setup used estimation.","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/set_residual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set Residual Distribution Functions for Hawkes Model Specification — set_residual","text":"","code":"if (FALSE) { # \\dontrun{ # Create basic Hawkes specification hspec_obj <- new(\"hspec\",                  mu = matrix(0.1, nrow = 1),                  alpha = matrix(0.5, nrow = 1),                  beta = matrix(1.0, nrow = 1))  # Set residual distribution parameters params <- c(a = 0.5, ell = 1.0)  # Apply residual functions hspec_obj <- set_residual(   hspec_obj,   param = params,   dresidual = dtzexp,   presidual = ptzexp,   qresidual = qtzexp,   rresidual = rtzexp )  # Check resulting functions hspec_obj@dresidual hspec_obj@rresidual } # }"},{"path":"https://ksublee.github.io/emhawkes/reference/tzexp.html","id":null,"dir":"Reference","previous_headings":"","what":"Trapezoid + Exponential Distribution — tzexp","title":"Trapezoid + Exponential Distribution — tzexp","text":"functions implement custom distribution combining trapezoidal section (0 < x < ) exponential tail (\\(x \\geq \\)). distribution parameterized : : transition point trapezoid exponential ell: rate parameter exponential tail","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/tzexp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trapezoid + Exponential Distribution — tzexp","text":"","code":"dtzexp(x, a, ell)  ptzexp(q, a, ell)  qtzexp(p, a, ell)  rtzexp(n, a, ell)"},{"path":"https://ksublee.github.io/emhawkes/reference/tzexp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trapezoid + Exponential Distribution — tzexp","text":"x, q vector quantiles location parameter transition (must > 0) ell rate parameter exponential decay (must > 0) p vector probabilities n number observations","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/tzexp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trapezoid + Exponential Distribution — tzexp","text":"dtzexp gives density ptzexp gives distribution function qtzexp gives quantile function rtzexp generates random deviates","code":""},{"path":"https://ksublee.github.io/emhawkes/reference/tzexp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Trapezoid + Exponential Distribution — tzexp","text":"Density, distribution function, quantile function random generation custom trapezoid + exponential distribution. trapezoid+exponential distribution probability density function: $$ f(x) = \\begin{cases} 0 & \\text{} x \\leq 0 \\\\ \\frac{(p\\ell - c)}{} x + c & \\text{} 0 < x < \\\\ p\\ell e^{-\\ell (x - )} & \\text{} x \\geq \\end{cases} $$ : $$ p = \\frac{\\ell - \\frac{\\ell}{3}}{\\frac{^2\\ell^2}{6} + \\frac{2a\\ell}{3} + 1} $$ $$ c = \\frac{2 - 2p - p\\ell }{} $$ trapezoid+exponential distribution following characteristics: Support \\([0, \\infty)\\) Continuous probability distribution Linear density 0 Exponential decay x > ","code":""},{"path":"https://ksublee.github.io/emhawkes/news/index.html","id":"emhawkes-097","dir":"Changelog","previous_headings":"","what":"emhawkes 0.9.7","title":"emhawkes 0.9.7","text":"CRAN release: 2023-02-02 Fixed bugs","code":""},{"path":"https://ksublee.github.io/emhawkes/news/index.html","id":"breaking-changes-0-9-7","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"emhawkes 0.9.7","text":"Flexible residual point process self/mutually exciting exponential decay model available.","code":""},{"path":"https://ksublee.github.io/emhawkes/news/index.html","id":"emhawkes-097-1","dir":"Changelog","previous_headings":"","what":"emhawkes 0.9.7","title":"emhawkes 0.9.7","text":"CRAN release: 2023-02-02 Fixed bugs, improved efficiency version several features added.","code":""},{"path":"https://ksublee.github.io/emhawkes/news/index.html","id":"breaking-changes-0-9-7-1","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"emhawkes 0.9.7","text":"lambda0 argument name used previous versions changed lambda_component0 version. clearly indicate meaning argument avoid confusion. name method vol changed hvol feature currently experimental. Vignette file contains examples explanations.","code":""},{"path":"https://ksublee.github.io/emhawkes/news/index.html","id":"emhawkes-096","dir":"Changelog","previous_headings":"","what":"emhawkes 0.9.6","title":"emhawkes 0.9.6","text":"Fixed bugs, improved efficiency version several features added.","code":""},{"path":"https://ksublee.github.io/emhawkes/news/index.html","id":"breaking-changes-0-9-6","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"emhawkes 0.9.6","text":"Slot eta introduced represents constant part impact. concepts rambda rambda_component introduced. closely related right-continuous version intensity process. inference intensity goodness fit, infer_lambda residual_process functions implemented. method vol measure volatility introduced feature currently experimental.","code":""}]
